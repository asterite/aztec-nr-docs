<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct PublicCallInterface documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">aztec-nr</a></h1>
<div><a href="../../../all.html">All items</a></div>
<h2 id="crate-name"><a href="../../index.html">noir_aztec</a></h2>
<div id="crate-version">0.0.0</div>
<h2><a href="#struct">Struct PublicCallInterface</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#call">call</a></li>
<li><a href="#enqueue">enqueue</a></li>
<li><a href="#enqueue_view">enqueue_view</a></li>
<li><a href="#new">new</a></li>
<li><a href="#set_as_teardown">set_as_teardown</a></li>
<li><a href="#view">view</a></li>
<li><a href="#with_gas">with_gas</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-CallInterface&lt;M&gt;-for-PublicCallInterface<M, T>">CallInterface&lt;M&gt;</a></li>
</ul>
<h2>In module call_interfaces</h2>
<h3>Structs</h3><ul class="item-list">
<li><a href="struct.PrivateCallInterface.html" class="struct">PrivateCallInterface</a></div></li>
<li><a href="struct.PrivateStaticCallInterface.html" class="struct">PrivateStaticCallInterface</a></div></li>
<li><a href="struct.PublicCallInterface.html" class="struct">PublicCallInterface</a></div></li>
<li><a href="struct.PublicStaticCallInterface.html" class="struct">PublicStaticCallInterface</a></div></li>
<li><a href="struct.UtilityCallInterface.html" class="struct">UtilityCallInterface</a></div></li>
</ul>
<h3>Traits</h3><ul class="item-list">
<li><a href="trait.CallInterface.html" class="trait">CallInterface</a></div></li>
</ul>
</nav>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">noir_aztec</a>::<a href="../index.html">context</a>::<a href="index.html">call_interfaces</a></div>
<h1>Struct <span id="struct" class="struct">PublicCallInterface</span></h1>
<pre><code>pub struct PublicCallInterface&lt;let M: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt;
{ <span class="comment">/* private fields */</span> }
</code></pre>
<h2>Implementations</h2>
<h3><code class="code-header">impl&lt;let M: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../noir_aztec/context/call_interfaces/struct.PublicCallInterface.html" class="struct">PublicCallInterface</a>&lt;M, T&gt;</code></h3>

<div class="padded-methods"><code id="new" class="code-header">pub fn <span class="fn">new</span>(
    target_contract: <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a>,
    selector: <a href="../../../protocol_types/abis/function_selector/struct.FunctionSelector.html" class="struct">FunctionSelector</a>,
    name: <a href="../../../std/primitive.str.html" class="primitive">str</a>&lt;M&gt;,
    args: [<a href="../../../std/primitive.Field.html" class="primitive">Field</a>],
    is_static: <a href="../../../std/primitive.bool.html" class="primitive">bool</a>,
) -> Self
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<code id="with_gas" class="code-header">pub fn <span class="fn">with_gas</span>(&mut self, gas_opts: <a href="../../../noir_aztec/context/gas/struct.GasOpts.html" class="struct">GasOpts</a>) -> &mut Self
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<code id="call" class="code-header">pub unconstrained fn <span class="fn">call</span>(self, context: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> T
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<div class="padded-description"><div class="comments">
<p>Makes the call to this public function.</p>
<p>Will revert if the called function reverts or runs out of gas.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - The PublicContext -- made magically available to the body
of every #[public] function as <code>context</code>, through the
#[public] annotation's macro.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>T</code> - Whatever data the called function has returned.</li>
</ul>
</div>
</div><code id="view" class="code-header">pub unconstrained fn <span class="fn">view</span>(self, context: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> T
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<div class="padded-description"><div class="comments">
<p>Makes a read-only call to this public function.</p>
<p>This is similar to Solidity's <code>staticcall</code>. The called function
cannot modify state or emit events. Any nested calls are constrained to
also be staticcalls.</p>
<p>Will revert if the called function reverts or runs out of gas.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - The PublicContext -- made magically available to the body
of every #[public] function as <code>context</code>, through the
#[public] annotation's macro.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>T</code> - Whatever data the called function has returned.</li>
</ul>
</div>
</div><code id="enqueue" class="code-header">pub fn <span class="fn">enqueue</span>(self, context: &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>)
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<div class="padded-description"><div class="comments">
<p>Enqueues a call to this public function, to be executed later.</p>
<p>Unlike private functions which execute immediately on the user's device,
public function calls are &quot;enqueued&quot; and executed some time later by a
block proposer.</p>
<p>This means a public function cannot return any values back to a private
function, because by the time the public function is being executed,
the private function which called it has already completed execution.
(In fact, the private function has been executed and proven, along with
all other private function calls of the user's tx. A single proof of the
tx has been submitted to the Aztec network, and some time later a
proposer has picked the tx up from the mempool and begun executing all
of the enqueued public functions).</p>
<h4>Privacy warning</h4>
<p>Enqueueing a public function call is an inherently leaky action.
Many interesting applications will require some interaction with public
state, but smart contract developers should try to use public function
calls sparingly, and carefully.
<em>Internal</em> public function calls are especially leaky, because they
completely leak which private contract made the call.
See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - The PrivateContext -- made magically available to the body
of every #[private] function as <code>context</code>, through the
#[private] annotation's macro.</li>
</ul>
</div>
</div><code id="enqueue_view" class="code-header">pub fn <span class="fn">enqueue_view</span>(self, context: &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>)
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<div class="padded-description"><div class="comments">
<p>Enqueues a read-only call to this public function.</p>
<p>This is similar to Solidity's <code>staticcall</code>. The called function
cannot modify state, emit L2-&gt;L1 messages, nor emit events. Any nested
calls are constrained to also be staticcalls.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - The PrivateContext -- made magically available to the body
of every #[private] function as <code>context</code>, through the
#[private] annotation's macro.</li>
</ul>
</div>
</div><code id="set_as_teardown" class="code-header">pub fn <span class="fn">set_as_teardown</span>(self, context: &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>)
<div class="where-clause">where
    T: <a href="../../../protocol_types/traits/trait.Deserialize.html" class="trait">Deserialize</a></div></code>

<div class="padded-description"><div class="comments">
<p>Enqueues a call to this public function, and designates it to be the
teardown function for this tx. Only one teardown function call can be
made by a tx.</p>
<p>Niche function: Only wallet developers and paymaster contract developers
(aka Fee-payment contracts) will need to make use of this function.</p>
<p>Aztec supports a three-phase execution model: setup, app logic, teardown.
The phases exist to enable a fee payer to take on the risk of paying
a transaction fee, safe in the knowledge that their payment (in whatever
token or method the user chooses) will succeed, regardless of whether
the app logic will succeed. The &quot;setup&quot; phase ensures the fee payer
has sufficient balance to pay the proposer their fees.
The teardown phase is primarily intended to: calculate exactly
how much the user owes, based on gas consumption, and refund the user
any change.</p>
<p>Note: in some cases, the cost of refunding the user (i.e. DA costs of
tx side-effects) might exceed the refund amount. For app logic with
fairly stable and predictable gas consumption, a material refund amount
is unlikely. For app logic with unpredictable gas consumption, a
refund might be important to the user (e.g. if a hefty function reverts
very early). Wallet/FPC/Paymaster developers should be mindful of this.</p>
<p>See <code>enqueue</code> for more information about enqueuing public function calls.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - The PrivateContext -- made magically available to the body
of every #[private] function as <code>context</code>, through the
#[private] annotation's macro.</li>
</ul>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-CallInterface&lt;M&gt;-for-PublicCallInterface<M, T>"><code class="code-header">impl&lt;let M: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../noir_aztec/context/call_interfaces/trait.CallInterface.html" class="trait">CallInterface</a>&lt;M&gt; for <a href="../../../noir_aztec/context/call_interfaces/struct.PublicCallInterface.html" class="struct">PublicCallInterface</a>&lt;M, T&gt;</code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">get_args</span>(self) -> [<a href="../../../std/primitive.Field.html" class="primitive">Field</a>]</code>

<code class="code-header">pub fn <span class="fn">get_selector</span>(self) -> <a href="../../../protocol_types/abis/function_selector/struct.FunctionSelector.html" class="struct">FunctionSelector</a></code>

<code class="code-header">pub fn <span class="fn">get_name</span>(self) -> <a href="../../../std/primitive.str.html" class="primitive">str</a>&lt;M&gt;</code>

<code class="code-header">pub fn <span class="fn">get_contract_address</span>(self) -> <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a></code>

<code class="code-header">pub fn <span class="fn">get_is_static</span>(self) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

</div></main>
</body>
</html>
