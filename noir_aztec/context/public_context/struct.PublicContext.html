<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct PublicContext documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">aztec-nr</a></h1><div><a href="../../../all.html">All items</a></div>
<h2><a href="#struct">Struct PublicContext</a></h2><h3>Fields</h3><ul class="sidebar-list"><li><a href="#args_hash">args_hash</a></li>
<li><a href="#compute_args_hash">compute_args_hash</a></li>
</ul><h3>Methods</h3><ul class="sidebar-list"><li><a href="#base_fee_per_da_gas">base_fee_per_da_gas</a></li>
<li><a href="#base_fee_per_l2_gas">base_fee_per_l2_gas</a></li>
<li><a href="#block_number">block_number</a></li>
<li><a href="#call_public_function">call_public_function</a></li>
<li><a href="#chain_id">chain_id</a></li>
<li><a href="#consume_l1_to_l2_message">consume_l1_to_l2_message</a></li>
<li><a href="#da_gas_left">da_gas_left</a></li>
<li><a href="#emit_public_log">emit_public_log</a></li>
<li><a href="#get_args_hash">get_args_hash</a></li>
<li><a href="#is_static_call">is_static_call</a></li>
<li><a href="#l1_to_l2_msg_exists">l1_to_l2_msg_exists</a></li>
<li><a href="#l2_gas_left">l2_gas_left</a></li>
<li><a href="#message_portal">message_portal</a></li>
<li><a href="#msg_sender">msg_sender</a></li>
<li><a href="#new">new</a></li>
<li><a href="#note_hash_exists">note_hash_exists</a></li>
<li><a href="#nullifier_exists">nullifier_exists</a></li>
<li><a href="#push_note_hash">push_note_hash</a></li>
<li><a href="#push_nullifier">push_nullifier</a></li>
<li><a href="#raw_storage_read">raw_storage_read</a></li>
<li><a href="#raw_storage_write">raw_storage_write</a></li>
<li><a href="#selector">selector</a></li>
<li><a href="#static_call_public_function">static_call_public_function</a></li>
<li><a href="#storage_read">storage_read</a></li>
<li><a href="#storage_write">storage_write</a></li>
<li><a href="#this_address">this_address</a></li>
<li><a href="#timestamp">timestamp</a></li>
<li><a href="#transaction_fee">transaction_fee</a></li>
<li><a href="#version">version</a></li>
</ul><h3>Trait implementations</h3><ul class="sidebar-list"><li><a href="#impl-Empty-for-PublicContext">Empty</a></li>
<li><a href="#impl-Eq-for-PublicContext">Eq</a></li>
</ul><h2>In module public_context</h2><h3>Structs</h3><ul class="item-list"><li><a href="struct.PublicContext.html" class="struct">PublicContext</a></div></li>
</ul><h3>Functions</h3><ul class="item-list"><li><a href="fn.avm_return.html" class="fn">avm_return</a></div></li>
<li><a href="fn.calldata_copy.html" class="fn">calldata_copy</a></div></li>
</ul></nav>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">noir_aztec</a>::<a href="../index.html">context</a>::<a href="index.html">public_context</a></div><h1>Struct <span id="struct" class="struct">PublicContext</span></h1><pre><code>pub struct PublicContext {
    pub args_hash: <a href="../../../std/option/struct.Option.html" class="struct">Option</a>&lt;Field&gt;,
    pub compute_args_hash: fn() -> Field,
}
</code></pre>
<div class="comments">
<h2>PublicContext</h2>
<p>The <strong>main interface</strong> between a #[public] function and the Aztec blockchain.</p>
<p>An instance of the PublicContext is initialized automatically at the outset
of every public function, within the #[public] macro, so you'll never
need to consciously instantiate this yourself.</p>
<p>The instance is always named <code>context</code>, and it will always be available
within the body of every #[public] function in your smart contract.</p>
<p>Typical usage for a smart contract developer will be to call getter
methods of the PublicContext.</p>
<p><em>Pushing</em> data and requests to the context is mostly handled within
aztec-nr's own functions, so typically a smart contract developer won't
need to call any setter methods directly.</p>
<h2>Responsibilities</h2>
<ul>
<li>Exposes contextual data to a public function:
<ul>
<li>Data relating to how this public function was called:
<ul>
<li>msg_sender, this_address</li>
</ul>
</li>
<li>Data relating to the current blockchain state:
<ul>
<li>timestamp, block_number, chain_id, version</li>
</ul>
</li>
<li>Gas and fee information</li>
</ul>
</li>
<li>Provides state access:
<ul>
<li>Read/write public storage (key-value mapping)</li>
<li>Check existence of notes and nullifiers
(Some patterns use notes &amp; nullifiers to store public (not private)
information)</li>
<li>Enables consumption of L1-&gt;L2 messages.</li>
</ul>
</li>
<li>Enables calls to other public smart contract functions:</li>
<li>Writes data to the blockchain:
<ul>
<li>Updates to public state variables</li>
<li>New public logs (for events)</li>
<li>New L2-&gt;L1 messages</li>
<li>New notes &amp; nullifiers
(E.g. pushing public info to notes/nullifiers, or for completing
&quot;partial notes&quot;)</li>
</ul>
</li>
</ul>
<h2>Key Differences from Private Execution</h2>
<p>Unlike private functions -- which are executed on the user's device and which
can only reference historic state -- public functions are executed by a block
proposer and are executed &quot;live&quot; on the <em>current</em> tip of the chain.
This means public functions can:</p>
<ul>
<li>Read and write <em>current</em> public state</li>
<li>Immediately see the effects of earlier transactions in the same block</li>
</ul>
<p>Also, public functions are executed within a zkVM (the &quot;AVM&quot;), so that they
can <em>revert</em> whilst still ensuring payment to the proposer and prover.
(Private functions cannot revert: they either succeed, or they cannot be
included).</p>
<h2>Optimising Public Functions</h2>
<p>Using the AVM to execute public functions means they compile down to &quot;AVM
bytecode&quot; instead of the ACIR that private functions (standalone circuits)
compile to. Therefore the approach to optimising a public function is
fundamentally different from optimising a public function.</p>
</div>
<h2>Fields</h2><div id="args_hash" class="struct-field"><code class="code-header">args_hash: <a href="../../../std/option/struct.Option.html" class="struct">Option</a>&lt;Field&gt;</code></div>
<div class="padded-description"></div><div id="compute_args_hash" class="struct-field"><code class="code-header">compute_args_hash: fn() -> Field</code></div>
<div class="padded-description"></div><h2>Implementations</h2><h3><code class="code-header">impl <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a></code></h3>

<div class="padded-methods"><code id="new" class="code-header">pub fn <span class="fn">new</span>(compute_args_hash: fn() -> Field) -> <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a></code>

<div class="padded-description"><div class="comments">
<p>Creates a new PublicContext instance.</p>
<p>Low-level function: This is called automatically by the #[public]
macro, so you shouldn't need to be called directly by smart contract
developers.</p>
<h4>Arguments</h4>
<ul>
<li><code>compute_args_hash</code> - Function to compute the args_hash</li>
</ul>
<h4>Returns</h4>
<ul>
<li>A new PublicContext instance</li>
</ul>
</div>
</div><code id="emit_public_log" class="code-header">pub fn <span class="fn">emit_public_log</span>&lt;T&gt;(_self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, log: T)
where
    T: <a href="../../../protocol_types/traits/trait.Serialize.html" class="trait">Serialize</a>&lt;N = &lt;T as Serialize&gt;::N&gt;
</code>

<div class="padded-description"><div class="comments">
<p>Emits a <em>public</em> log that will be visible onchain to everyone.</p>
<h4>Arguments</h4>
<ul>
<li><code>log</code> - The data to log, must implement Serialize trait</li>
</ul>
</div>
</div><code id="note_hash_exists" class="code-header">pub fn <span class="fn">note_hash_exists</span>(
    _self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    note_hash: Field,
    leaf_index: u64,
) -> bool</code>

<div class="padded-description"><div class="comments">
<p>Checks if a given note hash exists in the note hash tree at a particular
leaf_index.</p>
<h4>Arguments</h4>
<ul>
<li><code>note_hash</code> - The note hash to check for existence</li>
<li><code>leaf_index</code> - The index where the note hash should be located</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>bool</code> - True if the note hash exists at the specified index</li>
</ul>
</div>
</div><code id="l1_to_l2_msg_exists" class="code-header">pub fn <span class="fn">l1_to_l2_msg_exists</span>(
    _self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    msg_hash: Field,
    msg_leaf_index: Field,
) -> bool</code>

<div class="padded-description"><div class="comments">
<p>Checks if a specific L1-to-L2 message exists in the L1-to-L2 message
tree at a particular leaf index.</p>
<p>Common use cases include token bridging, cross-chain governance, and
triggering L2 actions based on L1 events.</p>
<p>This function should be called before attempting to consume an L1-to-L2
message.</p>
<h4>Arguments</h4>
<ul>
<li><code>msg_hash</code> - Hash of the L1-to-L2 message to check</li>
<li><code>msg_leaf_index</code> - The index where the message should be located</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>bool</code> - True if the message exists at the specified index</li>
</ul>
<h4>Advanced</h4>
<ul>
<li>Uses the AVM l1_to_l2_msg_exists opcode for tree lookup</li>
<li>Messages are copied from L1 Inbox to L2 by block proposers</li>
</ul>
</div>
</div><code id="nullifier_exists" class="code-header">pub fn <span class="fn">nullifier_exists</span>(
    _self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    unsiloed_nullifier: Field,
    address: <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a>,
) -> bool</code>

<div class="padded-description"><div class="comments">
<p>Checks if a specific nullifier has been emitted by a given contract.</p>
<p>Whilst nullifiers are primarily intended as a <em>privacy-preserving</em>
record of a one-time action, they can also be used to efficiently
record <em>public</em> one-time actions too. An example is to check
whether a contract has been published: we emit a nullifier that is
deterministic, but whose preimage is <em>not</em> private. This is more
efficient than using mutable storage, and can be done directly
from a private function.</p>
<p>Nullifiers can be tested for non-existence in public, which is not the
case in private. Because private functions do not have access to
the tip of the blockchain (but only the anchor block they are built
at) they can only prove nullifier non-existence in the past. But between
an anchor block and the block in which a tx is included, the nullifier
might have been inserted into the nullifier tree by some other
transaction.
Public functions <em>do</em> have access to the tip of the state, and so
this pattern is safe.</p>
<h4>Arguments</h4>
<ul>
<li><code>unsiloed_nullifier</code> - The raw nullifier value (before siloing with
the contract address that emitted it).</li>
<li><code>address</code> - The claimed contract address that emitted the nullifier</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>bool</code> - True if the nullifier has been emitted by the specified contract</li>
</ul>
</div>
</div><code id="consume_l1_to_l2_message" class="code-header">pub fn <span class="fn">consume_l1_to_l2_message</span>(
    &mut self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    content: Field,
    secret: Field,
    sender: <a href="../../../protocol_types/address/eth_address/struct.EthAddress.html" class="struct">EthAddress</a>,
    leaf_index: Field,
)</code>

<div class="padded-description"><div class="comments">
<p>Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively
marking it as &quot;read&quot;.</p>
<p>Use this function if you only want the message to ever be &quot;referred to&quot;
once. Once consumed using this method, the message cannot be consumed
again, because a nullifier is emitted.
If your use case wants for the message to be read unlimited times, then
you can always read any historic message from the L1-to-L2 messages tree,
using the <code>l1_to_l2_msg_exists</code> method. Messages never technically get
deleted from that tree.</p>
<p>The message will first be inserted into an Aztec &quot;Inbox&quot; smart contract
on L1. It will not be available for consumption immediately. Messages
get copied-over from the L1 Inbox to L2 by the next Proposer in batches.
So you will need to wait until the messages are copied before you can
consume them.</p>
<h4>Arguments</h4>
<ul>
<li><code>content</code> - The message content that was sent from L1</li>
<li><code>secret</code> - Secret value used for message privacy (if needed)</li>
<li><code>sender</code> - Ethereum address that sent the message</li>
<li><code>leaf_index</code> - Index of the message in the L1-to-L2 message tree</li>
</ul>
<h4>Advanced</h4>
<ul>
<li>Validates message existence in the L1-to-L2 message tree</li>
<li>Prevents double-consumption by emitting a nullifier</li>
<li>Message hash is computed from all parameters + chain context</li>
<li>Will revert if message doesn't exist or was already consumed</li>
</ul>
</div>
</div><code id="message_portal" class="code-header">pub fn <span class="fn">message_portal</span>(
    _self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    recipient: <a href="../../../protocol_types/address/eth_address/struct.EthAddress.html" class="struct">EthAddress</a>,
    content: Field,
)</code>

<div class="padded-description"><div class="comments">
<p>Sends an &quot;L2 -&gt; L1 message&quot; from this function (Aztec, L2) to a smart
contract on Ethereum (L1). L1 contracts which are designed to
send/receive messages to/from Aztec are called &quot;Portal Contracts&quot;.</p>
<p>Common use cases include withdrawals, cross-chain asset transfers, and
triggering L1 actions based on L2 state changes.</p>
<p>The message will be inserted into an Aztec &quot;Outbox&quot; contract on L1,
when this transaction's block is proposed to L1.
Sending the message will not result in any immediate state changes in
the target portal contract. The message will need to be manually
consumed from the Outbox through a separate Ethereum transaction: a user
will need to call a function of the portal contract -- a function
specifically designed to make a call to the Outbox to consume the
message.
The message will only be available for consumption once the <em>epoch</em>
proof has been submitted. Given that there are multiple Aztec blocks
within an epoch, it might take some time for this epoch proof to be
submitted -- especially if the block was near the start of an epoch.</p>
<h4>Arguments</h4>
<ul>
<li><code>recipient</code> - Ethereum address that will receive the message</li>
<li><code>content</code> - Message content (32 bytes as a Field element)</li>
</ul>
</div>
</div><code id="call_public_function" class="code-header">pub unconstrained fn <span class="fn">call_public_function</span>(
    _self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    contract_address: <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a>,
    function_selector: <a href="../../../protocol_types/abis/function_selector/struct.FunctionSelector.html" class="struct">FunctionSelector</a>,
    args: [Field],
    gas_opts: <a href="../../../noir_aztec/context/gas/struct.GasOpts.html" class="struct">GasOpts</a>,
) -> [Field]</code>

<div class="padded-description"><div class="comments">
<p>Calls a public function on another contract.</p>
<p>Will revert if the called function reverts or runs out of gas.</p>
<h4>Arguments</h4>
<ul>
<li><code>contract_address</code> - Address of the contract to call</li>
<li><code>function_selector</code> - Function to call on the target contract</li>
<li><code>args</code> - Arguments to pass to the function</li>
<li><code>gas_opts</code> - An optional allocation of gas to the called function.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>[Field]</code> - Return data from the called function</li>
</ul>
</div>
</div><code id="static_call_public_function" class="code-header">pub unconstrained fn <span class="fn">static_call_public_function</span>(
    _self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    contract_address: <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a>,
    function_selector: <a href="../../../protocol_types/abis/function_selector/struct.FunctionSelector.html" class="struct">FunctionSelector</a>,
    args: [Field],
    gas_opts: <a href="../../../noir_aztec/context/gas/struct.GasOpts.html" class="struct">GasOpts</a>,
) -> [Field]</code>

<div class="padded-description"><div class="comments">
<p>Makes a read-only call to a public function on another contract.</p>
<p>This is similar to Solidity's <code>staticcall</code>. The called function
cannot modify state or emit events. Any nested calls are constrained to
also be staticcalls.</p>
<p>Useful for querying data from other contracts safely.</p>
<p>Will revert if the called function reverts or runs out of gas.</p>
<h4>Arguments</h4>
<ul>
<li><code>contract_address</code> - Address of the contract to call</li>
<li><code>function_selector</code> - Function to call on the target contract</li>
<li><code>args</code> - Array of arguments to pass to the called function</li>
<li><code>gas_opts</code> - An optional allocation of gas to the called function.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>[Field]</code> - Return data from the called function</li>
</ul>
</div>
</div><code id="push_note_hash" class="code-header">pub fn <span class="fn">push_note_hash</span>(_self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, note_hash: Field)</code>

<div class="padded-description"><div class="comments">
<p>Adds a new note hash to the Aztec blockchain's global Note Hash Tree.</p>
<p>Notes are ordinarily constructed and emitted by <em>private</em> functions, to
ensure that both the content of the note, and the contract that emitted
the note, stay private.</p>
<p>There are however some useful patterns whereby a note needs to contain
<em>public</em> data. The ability to push a new note_hash from a <em>public</em>
function means that notes can be injected with public data immediately
-- as soon as the public value is known. The slower alternative would
be to submit a follow-up transaction so that a private function can
inject the data. Both are possible on Aztec.</p>
<p>Search &quot;Partial Note&quot; for a very common pattern which enables a note
to be &quot;partially&quot; populated with some data in a <em>private</em> function, and
then later &quot;completed&quot; with some data in a public function.</p>
<h4>Arguments</h4>
<ul>
<li><code>note_hash</code> - The hash of the note to add to the tree</li>
</ul>
<h4>Advanced</h4>
<ul>
<li>The note hash will be siloed with the contract address by the protocol</li>
</ul>
</div>
</div><code id="push_nullifier" class="code-header">pub fn <span class="fn">push_nullifier</span>(_self: &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, nullifier: Field)</code>

<div class="padded-description"><div class="comments">
<p>Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.</p>
<p>Whilst nullifiers are primarily intended as a <em>privacy-preserving</em>
record of a one-time action, they can also be used to efficiently
record <em>public</em> one-time actions too. Hence why you're seeing this
function within the PublicContext.
An example is to check whether a contract has been published: we emit
a nullifier that is deterministic, but whose preimage is <em>not</em> private.</p>
<h4>Arguments</h4>
<ul>
<li><code>nullifier</code> - A unique field element that represents the consumed
state</li>
</ul>
<h4>Advanced</h4>
<ul>
<li>Nullifier is immediately added to the global nullifier tree</li>
<li>Emitted nullifiers are immediately visible to all
subsequent transactions in the same block</li>
<li>Automatically siloed with the contract address by the protocol</li>
<li>Used for preventing double-spending and ensuring one-time actions</li>
</ul>
</div>
</div><code id="this_address" class="code-header">pub fn <span class="fn">this_address</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the address of the current contract being executed.</p>
<p>This is equivalent to <code>address(this)</code> in Solidity (hence the name).
Use this to identify the current contract's address, commonly needed for
access control or when interacting with other contracts.</p>
<h4>Returns</h4>
<ul>
<li><code>AztecAddress</code> - The contract address of the current function being
executed.</li>
</ul>
</div>
</div><code id="msg_sender" class="code-header">pub fn <span class="fn">msg_sender</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> <a href="../../../protocol_types/address/aztec_address/struct.AztecAddress.html" class="struct">AztecAddress</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the contract address that initiated this function call.</p>
<p>This is similar to <code>msg.sender</code> in Solidity (hence the name).</p>
<p>Important Note: Since Aztec doesn't have a concept of an EoA (
Externally-owned Account), the msg_sender is &quot;undefined&quot; for the first
function call of every transaction. A value of <code>-1</code> is returned in such
cases, and is enforced by the protocol's kernel circuits.
The first function call of a tx is likely to be a call to the user's
account contract, so this quirk will most often be handled by account
contract developers.</p>
<h4>Returns</h4>
<ul>
<li><code>AztecAddress</code> - The address of the account or contract that called
this function</li>
</ul>
<h4>Examples</h4>
<pre><code class="language-rust">#[aztec(public)]
fn transfer(context: &amp;mut PublicContext, to: AztecAddress, amount: u64) {
    let sender = context.msg_sender();
    // Only the sender can transfer their own tokens
    assert(sender == get_token_owner(), &quot;Unauthorized&quot;);
}
</code></pre>
<h4>Advanced</h4>
<ul>
<li>Value is provided by the AVM sender opcode</li>
<li>In nested calls, this is the immediate caller, not the original
transaction sender</li>
<li>Globally visible unlike private execution where it's contract-local</li>
</ul>
</div>
</div><code id="selector" class="code-header">pub fn <span class="fn">selector</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> <a href="../../../protocol_types/abis/function_selector/struct.FunctionSelector.html" class="struct">FunctionSelector</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the function selector of the currently-executing function.</p>
<p>This is similar to <code>msg.sig</code> in Solidity, returning the first 4
bytes of the function signature.</p>
<h4>Returns</h4>
<ul>
<li><code>FunctionSelector</code> - The 4-byte function identifier</li>
</ul>
<h4>Advanced</h4>
<ul>
<li>Extracted from the first element of calldata</li>
<li>Used internally for function dispatch in the AVM</li>
</ul>
</div>
</div><code id="get_args_hash" class="code-header">pub fn <span class="fn">get_args_hash</span>(self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> Field</code>

<div class="padded-description"><div class="comments">
<p>Returns the hash of the arguments passed to the current function.</p>
<p>Very low-level function: The #[public] macro uses this internally.
Smart contract developers typically won't need to access this
directly as arguments are automatically made available.</p>
<h4>Returns</h4>
<ul>
<li><code>Field</code> - Hash of the function arguments</li>
</ul>
</div>
</div><code id="transaction_fee" class="code-header">pub fn <span class="fn">transaction_fee</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> Field</code>

<div class="padded-description"><div class="comments">
<p>Returns the &quot;transaction fee&quot; for the current transaction.
This is the final tx fee that will be deducted from the fee_payer's
&quot;fee-juice&quot; balance (in the protocol's Base Rollup circuit).</p>
<h4>Returns</h4>
<ul>
<li><code>Field</code> - The actual, final cost of the transaction, taking into account:
the actual gas used during the setup and app-logic phases,
and the fixed amount of gas that's been allocated by the user
for the teardown phase.
I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed</li>
</ul>
<p>This will return <code>0</code> during the &quot;setup&quot; and &quot;app-logic&quot; phases of
tx execution (because the final tx fee is not known at that time).
This will only return a nonzero value during the &quot;teardown&quot; phase of
execution, where the final tx fee can actually be computed.</p>
<p>Regardless of <em>when</em> this function is called during the teardown phase,
it will always return the same final tx fee value. The teardown phase
does not consume a variable amount of gas: it always consumes a
pre-allocated amount of gas, as specified by the user when they generate
their tx.</p>
</div>
</div><code id="chain_id" class="code-header">pub fn <span class="fn">chain_id</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> Field</code>

<div class="padded-description"><div class="comments">
<p>Returns the chain ID of the current network.</p>
<p>This is similar to <code>block.chainid</code> in Solidity. Returns the unique
identifier for the blockchain network this transaction is executing on.</p>
<p>Helps prevent cross-chain replay attacks. Useful if implementing
multi-chain contract logic.</p>
<h4>Returns</h4>
<ul>
<li><code>Field</code> - The chain ID as a field element</li>
</ul>
</div>
</div><code id="version" class="code-header">pub fn <span class="fn">version</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> Field</code>

<div class="padded-description"><div class="comments">
<p>Returns the Aztec protocol version that this transaction is executing
under. Different versions may have different rules, opcodes, or
cryptographic primitives.</p>
<p>This is similar to how Ethereum has different EVM versions.</p>
<p>Useful for forward/backward compatibility checks</p>
<p>Not to be confused with contract versions; this is the protocol version.</p>
<h4>Returns</h4>
<ul>
<li><code>Field</code> - The protocol version as a field element</li>
</ul>
</div>
</div><code id="block_number" class="code-header">pub fn <span class="fn">block_number</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> u32</code>

<div class="padded-description"><div class="comments">
<p>Returns the current block number.</p>
<p>This is similar to <code>block.number</code> in Solidity.</p>
<p>Note: the current block number is only available within a public function
(as opposed to a private function).</p>
<p>Note: the time intervals between blocks should not be relied upon as
being consistent:</p>
<ul>
<li>Timestamps of blocks fall within a range, rather than at exact regular
intervals.</li>
<li>Slots can be missed.</li>
<li>Protocol upgrades can completely change the intervals between blocks
(and indeed the current roadmap plans to reduce the time between
blocks, eventually).
Use <code>context.timestamp()</code> for more-reliable time-based logic.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>u32</code> - The current block number</li>
</ul>
</div>
</div><code id="timestamp" class="code-header">pub fn <span class="fn">timestamp</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> u64</code>

<div class="padded-description"><div class="comments">
<p>Returns the timestamp of the current block.</p>
<p>This is similar to <code>block.timestamp</code> in Solidity.</p>
<p>All functions of all transactions in a block share the exact same
timestamp (even though technically each transaction is executed
one-after-the-other).</p>
<p>Important note: Timestamps of Aztec blocks are not at reliably-fixed
intervals. The proposer of the block has some flexibility to choose a
timestamp which is in a valid <em>range</em>: Obviously the timestamp of this
block must be strictly greater than that of the previous block, and must
must be less than the timestamp of whichever ethereum block the aztec
block is proposed to. Furthermore, if the timestamp is not deemed close
enough to the actual current time, the committee of validators will not
attest to the block.</p>
<h4>Returns</h4>
<ul>
<li><code>u64</code> - Unix timestamp in seconds</li>
</ul>
</div>
</div><code id="base_fee_per_l2_gas" class="code-header">pub fn <span class="fn">base_fee_per_l2_gas</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> u128</code>

<div class="padded-description"><div class="comments">
<p>Returns the fee per unit of L2 gas for this transaction (aka the &quot;L2 gas
price&quot;), as chosen by the user.</p>
<p>L2 gas covers the cost of executing public functions and handling
side-effects within the AVM.</p>
<h4>Returns</h4>
<ul>
<li><code>u128</code> - Fee per unit of L2 gas</li>
</ul>
<p>Wallet developers should be mindful that the choice of gas price (which
is publicly visible) can leak information about the user, e.g.:</p>
<ul>
<li>which wallet software the user is using;</li>
<li>the amount of time which has elapsed from the time the user's wallet
chose a gas price (at the going rate), to the time of tx submission.
This can give clues about the proving time, and hence the nature of
the tx.</li>
<li>the urgency of the transaction (which is kind of unavoidable, if the
tx is indeed urgent).</li>
<li>the wealth of the user.</li>
<li>the exact user (if the gas price is explicitly chosen by the user to
be some unique number like 0.123456789, or their favourite number).
Wallet devs might wish to consider fuzzing the choice of gas price.</li>
</ul>
</div>
</div><code id="base_fee_per_da_gas" class="code-header">pub fn <span class="fn">base_fee_per_da_gas</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> u128</code>

<div class="padded-description"><div class="comments">
<p>Returns the fee per unit of DA (Data Availability) gas (aka the &quot;DA gas
price&quot;).</p>
<p>DA gas covers the cost of making transaction data available on L1.</p>
<p>See the warning in <code>fee_pre_l2_gas</code> for how gas prices can be leaky.</p>
<h4>Returns</h4>
<ul>
<li><code>u128</code> - Fee per unit of DA gas</li>
</ul>
</div>
</div><code id="l2_gas_left" class="code-header">pub fn <span class="fn">l2_gas_left</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> u32</code>

<div class="padded-description"><div class="comments">
<p>Returns the remaining L2 gas available for this transaction.</p>
<p>Different AVM opcodes consume different amounts of gas.</p>
<h4>Returns</h4>
<ul>
<li><code>u32</code> - Remaining L2 gas units</li>
</ul>
</div>
</div><code id="da_gas_left" class="code-header">pub fn <span class="fn">da_gas_left</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> u32</code>

<div class="padded-description"><div class="comments">
<p>Returns the remaining DA (Data Availability) gas available for this
transaction.</p>
<p>DA gas is consumed when emitting data that needs to be made available
on L1, such as public logs or state updates.
All of the side-effects from the private part of the tx also consume
DA gas before execution of any public functions even begins.</p>
<h4>Returns</h4>
<ul>
<li><code>u32</code> - Remaining DA gas units</li>
</ul>
</div>
</div><code id="is_static_call" class="code-header">pub fn <span class="fn">is_static_call</span>(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> bool</code>

<div class="padded-description"><div class="comments">
<p>Checks if the current execution is within a staticcall context, where
no state changes or logs are allowed to be emitted (by this function
or any nested function calls).</p>
<h4>Returns</h4>
<ul>
<li><code>bool</code> - True if in staticcall context, false otherwise</li>
</ul>
</div>
</div><code id="raw_storage_read" class="code-header">pub fn <span class="fn">raw_storage_read</span>&lt;let N: u32&gt;(_self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, storage_slot: Field) -> [Field; N]</code>

<div class="padded-description"><div class="comments">
<p>Reads raw field values from public storage.
Reads N consecutive storage slots starting from the given slot.</p>
<p>Very low-level function. Users should typically use the public state
variable abstractions to perform reads: PublicMutable &amp; PublicImmutable.</p>
<h4>Arguments</h4>
<ul>
<li><code>storage_slot</code> - The starting storage slot to read from</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>[Field; N]</code> - Array of N field values from consecutive storage slots</li>
</ul>
<h4>Generic Parameters</h4>
<ul>
<li><code>N</code> - the number of consecutive slots to return, starting from the
<code>storage_slot</code>.</li>
</ul>
</div>
</div><code id="storage_read" class="code-header">pub fn <span class="fn">storage_read</span>&lt;T&gt;(self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, storage_slot: Field) -> T
where
    T: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;T as Packable&gt;::N&gt;
</code>

<div class="padded-description"><div class="comments">
<p>Reads a typed value from public storage.</p>
<p>Low-level function. Users should typically use the public state
variable abstractions to perform reads: PublicMutable &amp; PublicImmutable.</p>
<h4>Arguments</h4>
<ul>
<li><code>storage_slot</code> - The storage slot to read from</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>T</code> - The deserialized value from storage</li>
</ul>
<h4>Generic Parameters</h4>
<ul>
<li><code>T</code> - The type that the caller expects to read from the <code>storage_slot</code>.</li>
</ul>
</div>
</div><code id="raw_storage_write" class="code-header">pub fn <span class="fn">raw_storage_write</span>&lt;let N: u32&gt;(
    _self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    storage_slot: Field,
    values: [Field; N],
)</code>

<div class="padded-description"><div class="comments">
<p>Writes raw field values to public storage.
Writes to N consecutive storage slots starting from the given slot.</p>
<p>Very low-level function. Users should typically use the public state
variable abstractions to perform writes: PublicMutable &amp; PublicImmutable.</p>
<p>Public storage writes take effect immediately.</p>
<h4>Arguments</h4>
<ul>
<li><code>storage_slot</code> - The starting storage slot to write to</li>
<li><code>values</code> - Array of N Fields to write to storage</li>
</ul>
</div>
</div><code id="storage_write" class="code-header">pub fn <span class="fn">storage_write</span>&lt;T&gt;(
    self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>,
    storage_slot: Field,
    value: T,
)
where
    T: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;T as Packable&gt;::N&gt;
</code>

<div class="padded-description"><div class="comments">
<p>Writes a typed value to public storage.</p>
<p>Low-level function. Users should typically use the public state
variable abstractions to perform writes: PublicMutable &amp; PublicImmutable.</p>
<h4>Arguments</h4>
<ul>
<li><code>storage_slot</code> - The storage slot to write to</li>
<li><code>value</code> - The typed value to write to storage</li>
</ul>
<h4>Generic Parameters</h4>
<ul>
<li><code>T</code> - The type to write to storage.</li>
</ul>
</div>
</div></div><h2>Trait implementations</h2><h3 id="impl-Empty-for-PublicContext"><code class="code-header">impl <a href="../../../protocol_types/traits/trait.Empty.html" class="trait">Empty</a> for <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a></code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">empty</span>() -> <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a></code>

<code class="code-header">pub fn <span class="fn">is_empty</span>(self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> bool</code>

<code class="code-header">pub fn <span class="fn">assert_empty</span>&lt;let S: u32&gt;(self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, msg: str&lt;S&gt;)</code>

</div><h3 id="impl-Eq-for-PublicContext"><code class="code-header">impl <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a></code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">eq</span>(self: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>, other: <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> bool</code>

</div></main>
</body>
</html>
