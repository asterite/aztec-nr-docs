<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct MessageDeliveryEnum documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">aztec-nr</a></h1><div><a href="../../../all.html">All items</a></div>
<h2><a href="#struct">Struct MessageDeliveryEnum</a></h2><h3>Fields</h3><ul class="sidebar-list"><li><a href="#CONSTRAINED_ONCHAIN">CONSTRAINED_ONCHAIN</a></li>
<li><a href="#UNCONSTRAINED_OFFCHAIN">UNCONSTRAINED_OFFCHAIN</a></li>
<li><a href="#UNCONSTRAINED_ONCHAIN">UNCONSTRAINED_ONCHAIN</a></li>
</ul><h2>In module event_interface</h2><h3>Structs</h3><ul class="item-list"><li><a href="struct.MessageDeliveryEnum.html" class="struct">MessageDeliveryEnum</a></div></li>
</ul><h3>Traits</h3><ul class="item-list"><li><a href="trait.EventInterface.html" class="trait">EventInterface</a></div></li>
</ul><h3>Functions</h3><ul class="item-list"><li><a href="fn.emit_event_in_private.html" class="fn">emit_event_in_private</a></div></li>
<li><a href="fn.emit_event_in_public.html" class="fn">emit_event_in_public</a></div></li>
</ul><h3>Globals</h3><ul class="item-list"><li><a href="global.MessageDelivery.html" class="global">MessageDelivery</a></div></li>
</ul></nav>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">noir_aztec</a>::<a href="../index.html">event</a>::<a href="index.html">event_interface</a></div><h1>Struct <span id="struct" class="struct">MessageDeliveryEnum</span></h1><pre><code>pub struct MessageDeliveryEnum {
    pub CONSTRAINED_ONCHAIN: u8,
    pub UNCONSTRAINED_ONCHAIN: u8,
    pub UNCONSTRAINED_OFFCHAIN: u8,
}
</code></pre>
<div class="comments">
<p>Specifies the configuration parameters for message delivery. There are two fundamental aspects to consider:</p>
<p>+----------------------------------------------------------------------------------------------------------+
| 1. Delivery Mechanism                                                                                    |
| - Messages can be delivered either on-chain or out-of-band                                               |
| - On-chain delivery uses the Aztec protocol's private log stream, submitted to L1 blobs and consuming DA |
| - Out-of-band delivery is implemented by the application (e.g. storing ciphertexts in cloud storage)     |
| - Out-of-band delivery cannot have any cryptographic constraints since messages are never stored on-chain|
+----------------------------------------------------------------------------------------------------------+</p>
<p>For on-chain delivery, we must also consider:</p>
<p>+----------------------------------------------------------------------------------------------------------+
| 2. Message Encryption and Tagging                                                                        |
| - Messages can use either constrained or unconstrained encryption                                        |
| - Constrained encryption guarantees the ciphertext is formed correctly but costs more in constraints,    |
|   which results in slower proving times                                                                  |
| - Unconstrained encryption trusts the sender but is cheaper constraint-wise and hence faster to prove    |
| - Tagging is an indexing mechanism that helps recipients locate their messages                           |
| - If tagging is not performed correctly by the sender, the recipient will not be able to find the message|
+----------------------------------------------------------------------------------------------------------+</p>
<p>For off-chain delivery, constrained encryption is not relevant since it doesn't provide any additional guarantees
over unconstrained encryption and is slower to prove (requiring more constraints).</p>
<p>There are three available delivery modes described below.</p>
</div>
<h2>Fields</h2><div id="CONSTRAINED_ONCHAIN" class="struct-field"><code class="code-header">CONSTRAINED_ONCHAIN: u8</code></div>
<div class="padded-description"><div class="comments">
<ol>
<li>Constrained On-chain</li>
</ol>
<ul>
<li>Uses constrained encryption and in the future constrained tagging (issue #14565) with on-chain delivery</li>
<li>Provides cryptographic guarantees that recipients can discover and decrypt messages (once #14565 is tackled)</li>
<li>Slowest proving times since encryption is constrained</li>
<li>Expensive since it consumes L1 blob space</li>
<li>Use when smart contracts need to make decisions based on message contents</li>
<li>Example 1: An escrow contract facilitating a private NFT sale that needs to verify payment before releasing
the NFT to the buyer.</li>
<li>Example 2: An application with private configuration where changes must be broadcast to all participants.
This ensures every user can access the latest configuration. Without notification of config changes,
users would be unable to read updated variables and therefore blocked from using the application's
functions. This pattern applies to all critical events that require universal broadcast.</li>
</ul>
<p>Safety: Despite being called CONSTRAINED_ONCHAIN, this delivery mode is currently NOT fully constrained.
The tag prefixing is unconstrained, meaning a malicious sender could manipulate the tag to prevent
recipient decryption. TODO(#14565): Implement proper constrained tag prefixing.</p>
</div>
</div><div id="UNCONSTRAINED_ONCHAIN" class="struct-field"><code class="code-header">UNCONSTRAINED_ONCHAIN: u8</code></div>
<div class="padded-description"><div class="comments">
<ol start="2">
<li>Unconstrained On-chain</li>
</ol>
<ul>
<li>Uses unconstrained encryption and tagging with on-chain delivery</li>
<li>Faster proving times since no constraints are used for encryption</li>
<li>Expensive since it consumes L1 blob space</li>
<li>Suitable when recipients can verify message validity through other means</li>
<li>Use this if you don't need the cryptographic guarantees of constrained encryption and tagging but
don't want to deal with setting up out-of-band delivery infrastructure as required by mode 3</li>
<li>Example: Depositing a privately-held NFT into an NFT-sale escrow contract. The buyers know the escrow
contract's decryption keys, they receive the message on-chain and are willing to buy the NFT only if the NFT
contained in the message is legitimate.</li>
</ul>
</div>
</div><div id="UNCONSTRAINED_OFFCHAIN" class="struct-field"><code class="code-header">UNCONSTRAINED_OFFCHAIN: u8</code></div>
<div class="padded-description"><div class="comments">
<ol start="3">
<li>Out-of-band</li>
</ol>
<ul>
<li>Uses unconstrained encryption with off-chain delivery</li>
<li>Lowest cost since no on-chain storage is needed and short proving times since no constraints are used
for encryption</li>
<li>Suitable when recipients can verify message validity through other means</li>
<li>Requires setting up custom infrastructure for handling off-chain delivery (e.g. cloud storage)</li>
<li>Example: A payment app where a merchant receives the message off-chain and is willing to release the goods
once he verifies that the payment is correct (i.e. can decrypt the message and verify that it contains
a legitimate token note - note with note commitment in the note hash tree).</li>
</ul>
</div>
</div></main>
</body>
</html>
