<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct PublicImmutable documentation</title>
</head>
<body>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">noir_aztec</a>::<a href="../index.html">state_vars</a>::<a href="index.html">public_immutable</a></div><h1>Struct <span class="struct">PublicImmutable</span></h1><pre><code>pub struct PublicImmutable&lt;T, Context&gt;
{ /* private fields */ }
</code></pre>
<div class="comments">
<h2>PublicImmutable</h2>
<p>PublicImmutable is a public state variable type for values that are set once
during initialization and remain permanently unchanged.</p>
<p>You can declare a state variable of type PublicImmutable within your contract's
#[storage] struct:</p>
<p>E.g.:
<code>your_variable: PublicImmutable&lt;T, Context&gt;</code></p>
<p>PublicImmutable stores an immutable value in public state which can be <em>read</em>
from public, utility and even <em>private</em> execution contexts.</p>
<p>The methods of PublicImmutable are:</p>
<ul>
<li><code>initialize</code></li>
<li><code>read</code>
(see the methods' own doc comments for more info).</li>
</ul>
<h2>Generic Parameters:</h2>
<ul>
<li><code>T</code> - The type of value stored (must implement Packable).</li>
<li><code>Context</code> - The execution context (PublicContext, PrivateContext, or UtilityContext).</li>
</ul>
<h2>Advanced</h2>
<p>PublicImmutable leverages <code>WithHash&lt;T&gt;</code> to enable efficient private reads of
public storage. The <code>WithHash</code> wrapper optimizes reads by hashing values that would
be larger than a single field into a single field, then proving inclusion of only
the hash in public storage.</p>
<p>This optimization is particularly valuable when T packs to multiple fields,
as it maintains &quot;almost constant&quot; verification overhead regardless of the
original data size.</p>
<h2>Optimizing private reads in your contract</h2>
<p>Since reading T from public immutable storage in private contexts has &quot;almost
constant&quot; constraint costs regardless of T's size, it's recommended to group
multiple values into a single struct when they are to be read together. This is
typically useful for configuration data set during contract initialization. E.g.:</p>
<pre><code class="language-noir">use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};
use std::meta::derive;

#[derive(Eq, Packable)]
pub struct Config \{
    pub address_1: AztecAddress,
    pub value_1: u128,
    pub value_2: u64,
    ...
}
</code></pre>
</div>
<h2>Implementations</h2><h3><code class="code-header">impl&lt;T&gt; <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>&gt;</code></h3>

<code class="code-header">pub fn <span class="fn">initialize</span>(self: <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>&gt;, value: T)
where
    T: Packable<N = <T as Packable>::N>,
    T: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Initializes a PublicImmutable state variable instance with a permanent value.</p>
<p>This function sets the immutable value for this state variable. It can only
be called once per PublicImmutable. Subsequent calls will fail because the
initialization nullifier will already exist.</p>
<h4>Arguments</h4>
<ul>
<li><code>value</code> - The permanent value to store in this PublicImmutable.</li>
</ul>
<h4>Panics</h4>
<p>Panics if the value is already initialized.</p>
<h4>Advanced</h4>
<p>This function performs the following operations:</p>
<ul>
<li>Creates and emits an initialization nullifier to mark this storage slot
as initialized. This prevents double-initialization.</li>
<li>Wraps the value in <code>WithHash&lt;T&gt;</code> for efficient private reads.</li>
<li>Stores the wrapped value in Aztec's public data tree.</li>
</ul>
<p>docs:start:public_immutable_struct_write</p>
</div>
</div><code class="code-header">pub fn <span class="fn">read</span>(self: <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>&gt;) -> T
where
    T: Packable<N = <T as Packable>::N>,
    T: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Reads the permanent value stored in this PublicImmutable state variable.</p>
<h4>Returns</h4>
<ul>
<li><code>T</code> - The permanent value stored in this PublicImmutable.</li>
</ul>
<h4>Panics</h4>
<p>Panics if the value is not initialized.</p>
<h4>Advanced</h4>
<p>This function performs the following operations:</p>
<ul>
<li>Checks that the state variable has been initialized by verifying the
initialization nullifier exists</li>
<li>Reads the <code>WithHash&lt;T&gt;</code> wrapper from public storage</li>
<li>Extracts and returns the original value T</li>
</ul>
<p>The function will panic if called on an uninitialized PublicImmutable.</p>
<p>docs:start:public_immutable_struct_read</p>
</div>
</div><code class="code-header">pub fn <span class="fn">read_unsafe</span>(self: <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, &mut <a href="../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>&gt;) -> T
where
    T: Packable<N = <T as Packable>::N>,
    T: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Reads the value stored in this PublicImmutable without checking if the value
is initialized.</p>
<p>This function bypasses the initialization check and directly reads from
storage.
If the PublicImmutable has not been initialized, this will return a
zeroed value.
However, if the variable is <em>known</em> to be initialized, this is cheaper
to call than <code>read</code>.</p>
<h4>Returns</h4>
<ul>
<li><code>T</code> - The value stored in this PublicImmutable, or empty/default values if
uninitialized.</li>
</ul>
</div>
</div><h3><code class="code-header">impl&lt;Context, T&gt; <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, Context&gt;</code></h3>

<code class="code-header">pub fn <span class="fn">new</span>(context: Context, storage_slot: Field) -> <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, Context&gt;</code>

<div class="padded-description"><div class="comments">
<p>Initializes a new PublicImmutable state variable.</p>
<p>This function is usually automatically called within the #[storage] macro.
You typically don't need to call this directly when writing smart contracts.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - One of <code>PublicContext</code>/<code>PrivateContext</code>/<code>UtilityContext</code>. The
Context determines which methods of this struct will be made
available to the calling smart contract function.</li>
<li><code>storage_slot</code> - A unique identifier for this state variable within the
contract. Usually, the #[storage] macro will determine an
appropriate storage_slot automatically. A smart contract
dev shouldn't have to worry about this, as it's managed
behind the scenes.</li>
</ul>
<p>docs:start:public_immutable_struct_new</p>
</div>
</div><code class="code-header">pub fn <span class="fn">compute_initialization_nullifier</span>(self: <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, Context&gt;) -> Field</code>

<div class="padded-description"></div><h3><code class="code-header">impl&lt;T&gt; <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;</code></h3>

<code class="code-header">pub fn <span class="fn">read</span>(self: <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;) -> T
where
    T: Packable<N = <T as Packable>::N>,
    T: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Reads the permanent value stored in this PublicImmutable from the anchor
block.</p>
<p>Private functions execute asynchronously and offchain. When a user begins
private execution, their view of the chain 'branches off' from the current
public state, since public state continues to advance while they execute
privately. Therefore, private functions read from a historical snapshot of
public state rather than the current state.</p>
<h4>Returns</h4>
<ul>
<li><code>T</code> - The permanent value stored in this PublicImmutable at the historical
block referenced by the private context.</li>
</ul>
<h4>Advanced</h4>
<p>This function performs a historical read using the block header from the private
context. The <code>WithHash</code> optimization is particularly valuable here because it
reduces the number of required inclusion proofs by proving membership of
only the hash instead of the full packed value.</p>
<p>The historical read mechanism:</p>
<ul>
<li>Uses an oracle to obtain the value from the historical block</li>
<li>Proves inclusion of the value's hash in the public data tree</li>
<li>Proves that the root of this public data tree is correct, relative to the
historical block header that is being referenced by this private function.</li>
<li>Verifies that the oracle-provided value matches the stored hash</li>
</ul>
</div>
</div><h3><code class="code-header">impl&lt;T&gt; <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, <a href="../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>&gt;</code></h3>

<code class="code-header">pub unconstrained fn <span class="fn">read</span>(self: <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, <a href="../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>&gt;) -> T
where
    T: Packable<N = <T as Packable>::N>,
    T: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Reads the permanent value stored in this PublicImmutable state variable.</p>
<p>Notice that this function is executable only within a UtilityContext, which
is an unconstrained environment on the user's local device.</p>
<h4>Returns</h4>
<ul>
<li><code>T</code> - The permanent value stored in this PublicImmutable.</li>
</ul>
</div>
</div><h2>Trait implementations</h2><h3><code class="code-header">impl&lt;Context, let M: u32, T&gt; <a href="../../../noir_aztec/state_vars/storage/trait.HasStorageSlot.html" class="trait">HasStorageSlot</a>&lt;M + 1&gt; for <a href="../../../noir_aztec/state_vars/public_immutable/struct.PublicImmutable.html" class="struct">PublicImmutable</a>&lt;T, Context&gt;
where
    T: Packable<N = M>
</code></h3>

</main>
</body>
</html>
