<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../../styles.css">
<title>Struct TestEnvironment documentation</title>
</head>
<body>
<main>
<div><a href="../../../../index.html">aztec-nr</a> - <a href="../../../index.html">noir_aztec</a>::<a href="../../index.html">test</a>::<a href="../index.html">helpers</a>::<a href="index.html">test_environment</a></div><h1>Struct <span class="struct">TestEnvironment</span></h1><pre><code>pub struct TestEnvironment
{ /* private fields */ }
</code></pre>
<div class="comments">
<p>This represents an Aztec test run, and contains all the methods utilized during one to interact with the network and
manipulate its state (e.g. create accounts, make contract calls, etc.). Each test is expected to have its own
instance of <code>TestEnvironment</code>, as tests execute in parallel and so cannot share this object.</p>
<p>Most tests will begin by creating a <code>TestEnvironment</code> variable, and then make multiple calls to its different
methods. E.g.:</p>
<pre><code class="language-noir">#[test]
fn sample_test() {
    let mut env = TestEnvironment::new();

    // Create an account to call contracts from
    let account = env.create_light_account();
    // Deploy a compiled contract
    let contract_addr = env.deploy(&quot;MyContract&quot;).without_initializer();

    // Call a contract private function and get the return value
    let result = env.private_call(account, MyContract::at(contract_addr).sample_private_function());
    assert_eq(result, expected);
}
</code></pre>
</div>
<h2>Implementations</h2><h3><code class="code-header">impl <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a></code></h3>

<code class="code-header">pub unconstrained fn <span class="fn">new</span>() -> <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a></code>

<div class="padded-description"><div class="comments">
<p>Creates a new <code>TestEnvironment</code>. This function should only be called once per test.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">public_context</span>&lt;Env, T&gt;(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, f: fn[Env](&mut <a href="../../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> T) -> T</code>

<div class="padded-description"><div class="comments">
<p>Creates a <code>PublicContext</code>, which allows using aztec-nr features as if inside a public contract function. Useful
for low-level testing of public state variables and utilities.</p>
<p>A new block is automatically mined once <code>public_context</code> returns, containing all of the side effects caused by
its execution (e.g. public storage writes). It is however <strong>NOT</strong> possible to make any contract calls from this
public context - use <code>call_public</code> for testing contract calls (though usage of <code>call_public</code> is forbidden while
inside <code>public_context</code>).</p>
<p>Receives a callback function which is called with the created <code>PublicContext</code> - this function is where testing
logic is expected to reside. Any values returned by it are bubbled-up and returned to the caller of
<code>public_context</code>. Do <strong>NOT</strong> return the <code>PublicContext</code> from the callback function, or use it in any way outside
of it - it becomes invalid once <code>public_context</code> returns.</p>
<p>See <code>public_context_at</code> for a variant that allows specifying the contract address.</p>
<h4>Sample usage</h4>
<pre><code class="language-noir">env.public_context(|context| {
  let state_var = PublicMutable::new(context, STORAGE_SLOT);
  state_var.write(some_value);
  assert_eq(state_var.read(), some_value);
});
</code></pre>
<h4>Advanced usage with returns</h4>
<pre><code class="language-noir">let read_value = env.public_context(|context| {
  let state_var = PublicMutable::new(context, STORAGE_SLOT);
  state_var.read()
});
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">public_context_at</span>&lt;Env, T&gt;(
    _self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>,
    addr: AztecAddress,
    f: fn[Env](&mut <a href="../../../../noir_aztec/context/public_context/struct.PublicContext.html" class="struct">PublicContext</a>) -> T,
) -> T</code>

<div class="padded-description"><div class="comments">
<p>Variant of <code>public_context</code> which allows specifying the contract address in which the public context will
execute, which will affect note and nullifier siloing, storage access, etc.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">private_context</span>&lt;Env, T&gt;(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, f: fn[Env](&mut <a href="../../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>) -> T) -> T</code>

<div class="padded-description"><div class="comments">
<p>Creates a <code>PrivateContext</code>, which allows using aztec-nr features as if inside a private contract function.
Useful for low-level testing of private state variables and utilities.</p>
<p>A new block is automatically mined once <code>private_context</code> returns, containing all of the side effects caused by
its execution (e.g. note and nullifier emission). It is however <strong>NOT</strong> possible to make any contract calls from this
private context, neither private nor enqueued public calls - use <code>call_private</code> and <code>call_public</code> for testing
contract calls (though usage of these is forbidden while inside <code>private_context</code>).</p>
<p>Receives a callback function which is called with the created <code>PrivateContext</code> - this function is where testing
logic is expected to reside. Any values returned by it are bubbled-up and returned to the caller of
<code>private_context</code>. Do <strong>NOT</strong> return the <code>PrivateContext</code> from the callback function, or use it in any way
outside of it - it becomes invalid once <code>private_context</code> returns.</p>
<p>See <code>private_context_at</code> for a variant that allows specifying the contract address, or <code>private_context_opts</code>
for even more configurability.</p>
<h4>Sample usage</h4>
<pre><code class="language-noir">env.private_context(|context| {
  let state_var = PrivateMutable::new(context, STORAGE_SLOT);
  let note = SampleNote::new(some_value);
  state_var.initialize(note);
  assert_eq(state_var.get_note(), note);
});
</code></pre>
<h4>Advanced usage with returns</h4>
<pre><code class="language-noir">let note = env.private_context(|context| {
  let state_var = PrivateMutable::new(context, STORAGE_SLOT);
  state_var.get_note()
});
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">private_context_at</span>&lt;Env, T&gt;(
    _self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>,
    addr: AztecAddress,
    f: fn[Env](&mut <a href="../../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>) -> T,
) -> T</code>

<div class="padded-description"><div class="comments">
<p>Variant of <code>private_context</code> which allows specifying the contract address in which the private context will
execute, which will affect note and nullifier siloing, storage access, etc.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">private_context_opts</span>&lt;Env, T&gt;(
    _self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>,
    opts: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.PrivateContextOptions.html" class="struct">PrivateContextOptions</a>,
    f: fn[Env](&mut <a href="../../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>) -> T,
) -> T</code>

<div class="padded-description"><div class="comments">
<p>Variant of <code>private_context</code> which allows specifying multiple configuration values via <code>PrivateContextOptions</code>.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">utility_context</span>&lt;Env, T&gt;(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, f: fn[Env](<a href="../../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>) -> T) -> T</code>

<div class="padded-description"><div class="comments">
<p>Creates a <code>UtilityContext</code>, which allows using aztec-nr features as if inside a utility contract function.
Useful for low-level testing of private and public state variable utilities.</p>
<p>Receives a callback function which is called with the created <code>Utility</code> - this function is where testing
logic is expected to reside. Any values returned by it are bubbled-up and returned to the caller of
<code>utility_context</code>. Do <strong>NOT</strong> return the <code>Utility</code> from the callback function, or use it in any way outside of
it - it becomes invalid once <code>utility_context</code> returns.</p>
<p>See <code>utility_context_at</code> for a variant that allows specifying the contract address.</p>
<h4>Sample usage</h4>
<pre><code class="language-noir">env.utility_context(|context| {
  let state_var = PrivateMutable::new(context, STORAGE_SLOT);
  let note = SampleNote::new(some_value);
  assert_eq(state_var.view_note(), note);
});
</code></pre>
<h4>Advanced usage with returns</h4>
<pre><code class="language-noir">let note = env.utility_context(|context| {
  let state_var = PrivateMutable::new(context, STORAGE_SLOT);
  state_var.view_note()
});
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">utility_context_at</span>&lt;Env, T&gt;(
    _self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>,
    addr: AztecAddress,
    f: fn[Env](<a href="../../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>) -> T,
) -> T</code>

<div class="padded-description"><div class="comments">
<p>Variant of <code>utility_context</code> which allows specifying the contract address in which the utility context will
execute, which will affect note and storage access.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">next_block_number</span>(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>) -> u32</code>

<div class="padded-description"><div class="comments">
<p>Returns the number of the next block to be mined.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">last_block_number</span>(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>) -> u32</code>

<div class="padded-description"><div class="comments">
<p>Returns the number of the last mined block. This is the default historical block for <code>private_context</code> and
<code>private_call</code>.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">last_block_timestamp</span>(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>) -> u64</code>

<div class="padded-description"><div class="comments">
<p>Returns the timestamp of the last mined block. Note that block timestamps do not automatically advance - this
must be done by calling <code>mine_block_at</code> or <code>set_next_block_timestamp</code>.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">mine_block_at</span>(self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, timestamp: u64)</code>

<div class="padded-description"><div class="comments">
<p>Mines an empty block (i.e. with no transactions) at <code>timestamp</code>, causing followup public executions to occur at
that timestamp (e.g. via <code>call_public</code> or <code>public_context</code>), and making it possible to create private executions
at the specified timestamp (e.g. via <code>call_private</code> or <code>private_context</code>).</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">set_next_block_timestamp</span>(self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, timestamp: u64)</code>

<div class="padded-description"><div class="comments">
<p>Sets the timestamp of the next block to be mined, causing followup public executions to occur at that timestamp
(e.g. via <code>call_public</code> or <code>public_context</code>).</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">mine_block</span>(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>)</code>

<div class="padded-description"><div class="comments">
<p>Mines an empty block (i.e. with no transactions). Note that block timestamps do not automatically advance - this
must be done by calling <code>mine_block_at</code> or <code>set_next_block_timestamp</code>.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">advance_next_block_timestamp_by</span>(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, duration: u64)</code>

<div class="padded-description"><div class="comments">
<p>Sets the timestamp of the next block to be mined to be ahead of the last one by <code>duration</code>.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">create_contract_account</span>(&mut self: &mut <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>) -> AztecAddress</code>

<div class="padded-description"><div class="comments">
<p>Creates a new account that can be used as the <code>from</code> parameter in contract calls, e.g. in <code>private_call</code> or
<code>public_call</code>, or be made the owner or recipient of notes in <code>private_context</code>.</p>
<p>The returned account has a full set of privacy keys, so it can nullify notes, receive messages, etc. It also has
an associated <code>SchnorrAccount</code> contract that can process authwit requests - the authwits can be added via the
<code>add_private_authwit_from_call_interface</code> and <code>add_public_authwit_from_call_interface</code> helper functions. If
authwits are not required, consider using <code>create_light_account</code> instead, which is a faster variant of this
function.</p>
<p>Each call to <code>create_contract_account</code> will return a different address, and so it can be called repeatedly to
generate multiple addresses. These addresses are also different from the ones that <code>create_light_account</code>
returns, and so these two functions can be mixed and match to create a set of unique accounts.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">create_light_account</span>(&mut self: &mut <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>) -> AztecAddress</code>

<div class="padded-description"><div class="comments">
<p>Creates a new account that can be used as the <code>from</code> parameter in contract calls, e.g. in <code>private_call</code> or
<code>public_call</code>, or be made the owner or recipient of notes in <code>private_context</code>. This is a faster variant of
<code>create_contract_account</code>, but comes with reduced capabilities.</p>
<p>The returned account has a full set of privacy keys, so it can nullify notes, receive messages, etc. It doesn't
however have an associated account contract, so it cannot process private authwit requests. If calling contracts
that rely on private authwits, use <code>create_contract_account</code> instead.</p>
<p>Each call to <code>create_light_account</code> will return a different address, and so it can be called repeatedly to
generate multiple addresses. These addresses are also different from the ones that <code>create_contract_account</code>
returns, and so these two functions can be mixed and match to create a set of unique accounts.</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">deploy</span>&lt;let N: u32&gt;(&mut self: &mut <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, path: str<N>) -> <a href="../../../../noir_aztec/test/helpers/utils/struct.ContractDeployment.html" class="struct">ContractDeployment</a>&lt;N&gt;</code>

<div class="padded-description"><div class="comments">
<p>Prepares a contract for deployment, so that its private, public and utility functions can be called. The
contract <strong>must be already compiled</strong> before tests are run, and <strong>must be recompiled if changed</strong> for the tests
to deploy the updated version.</p>
<p>In order to finalize the deployment, the proper initializer function must be specified via one of the associated
methods. For more information on how to specify the path and initialization, read the sections below.</p>
<h4>Path</h4>
<p>Contracts can be deployed from either the same crate as the test, from a different crate in the same workspace,
or from an altogether independent crate.</p>
<p>If deploying contracts from the same crate as the test, just refer to it by its name:</p>
<pre><code class="language-noir">TestEnvironment::new().deploy(&quot;MyContract&quot;);
</code></pre>
<p>If deploying contracts from a different crate in the same workspace, use <code>@crate_name/contract_name</code>:</p>
<pre><code class="language-noir">TestEnvironment::new().deploy(&quot;@my_contract_crate/MyContract&quot;);
</code></pre>
<p>If deploying contracts from a crate not in the workspace, use <code>path_to_crate/contract_name</code>, with the crate path
relative to the current workspace:</p>
<pre><code class="language-noir">TestEnvironment::new().deploy(&quot;../my_other_crate/MyContract&quot;);
</code></pre>
<h4>Initialization</h4>
<p>If no initializer function needs to be called, use <code>without_initializer</code>:</p>
<pre><code class="language-noir">let my_contract = TestEnvironment::new().deploy(&quot;MyContract&quot;).without_initializer();
</code></pre>
<p>For private initializers, use <code>with_private_initializer</code>:</p>
<pre><code class="language-noir">let my_contract = TestEnvironment::new().deploy(&quot;MyContract&quot;).with_private_initializer(
  PrivateInitContract::interface().private_init_fn(init_args)
);
</code></pre>
<p>For public initializers, use <code>with_public_initializer</code>:</p>
<pre><code class="language-noir">let my_contract = TestEnvironment::new().deploy(&quot;MyContract&quot;).with_public_initializer(
  PublicInitContract::interface().public_init_fn(init_args)
);
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">call_private</span>&lt;T, let M: u32&gt;(
    _self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>,
    from: AztecAddress,
    call_interface: <a href="../../../../noir_aztec/context/call_interfaces/struct.PrivateCallInterface.html" class="struct">PrivateCallInterface</a>&lt;M, T&gt;,
) -> T
where
    T: Deserialize<N = <T as Deserialize>::N>
</code>

<div class="padded-description"><div class="comments">
<p>Performs a private contract function call, including the processing of any nested private calls and enqueued
public calls. Returns the result of the called function.</p>
<p>The function is called by the <code>from</code> address - use <code>create_contract_account</code> or <code>create_light_account</code> to
generate sender addresses, depending on whether support for private authwit verification is required or not.
Note that execution will begin directly in the called function - no entrypoint function in <code>from</code> will be
executed.</p>
<p>A transaction is created containing all side effects of the call, which is then included in a block that gets
mined by the time <code>call_private</code> returns. It is therefore possible to chain multiple private or public function
calls that operate on the result of prior calls.</p>
<p>The <code>call_interface</code> value can be obtained by calling the appropriate method on a contract type. E.g.:</p>
<pre><code class="language-noir">let caller = env.create_light_account();
let contract_addr = env.deploy(&quot;SampleContract&quot;).without_initializer();
let return_value = env.call_private(caller, SampleContract::at(contract_addr).sample_private_function());
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">view_private</span>&lt;T, let M: u32&gt;(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, call_interface: <a href="../../../../noir_aztec/context/call_interfaces/struct.PrivateStaticCallInterface.html" class="struct">PrivateStaticCallInterface</a>&lt;M, T&gt;) -> T
where
    T: Deserialize<N = <T as Deserialize>::N>
</code>

<div class="padded-description"><div class="comments">
<p>Variant of <code>call_private</code> for private <code>#[view]</code> functions.</p>
<p>Unlike <code>call_private</code>, no transaction is created and no block is mined (since <code>#[view]</code> functions are only
executable in a static context, and these produce no side effects).</p>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">simulate_utility</span>&lt;T, let M: u32&gt;(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, call_interface: <a href="../../../../noir_aztec/context/call_interfaces/struct.UtilityCallInterface.html" class="struct">UtilityCallInterface</a>&lt;M, T&gt;) -> T
where
    T: Deserialize<N = <T as Deserialize>::N>
</code>

<div class="padded-description"><div class="comments">
<p>Performs a utility contract function call and returns the result of the called function.</p>
<p>The <code>call_interface</code> value can be obtained by calling the appropriate method on a contract type. E.g.:</p>
<pre><code class="language-noir">let caller = env.create_light_account();
let contract_addr = env.deploy(&quot;SampleContract&quot;).without_initializer();
let return_value = env.simulate_utility(SampleContract::at(contract_addr).sample_utility_function());
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">call_public</span>&lt;T, let M: u32&gt;(
    _self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>,
    from: AztecAddress,
    call_interface: <a href="../../../../noir_aztec/context/call_interfaces/struct.PublicCallInterface.html" class="struct">PublicCallInterface</a>&lt;M, T&gt;,
) -> T
where
    T: Deserialize<N = <T as Deserialize>::N>
</code>

<div class="padded-description"><div class="comments">
<p>Performs a public contract function call, including the processing of any nested public calls. Returns the
result of the called function.</p>
<p>The function is called by the <code>from</code> address - use <code>create_contract_account</code> or <code>create_light_account</code> to
generate sender addresses. Note that execution will begin directly in the called function - no private
entrypoint function in <code>from</code> will be executed - in fact no private execution of any kind will be performed.</p>
<p>A transaction is created containing all side effects of the call, which is then included in a block that gets
mined by the time <code>call_public</code> returns. It is therefore possible to chain multiple private or public function
calls that operate on the result of prior calls.</p>
<p>The <code>call_interface</code> value can be obtained by calling the appropriate method on a contract type. E.g.:</p>
<pre><code class="language-noir">let caller = env.create_light_account();
let contract_addr = env.deploy(&quot;SampleContract&quot;).without_initializer();
let return_value = env.call_public(caller, SampleContract::at(contract_addr).sample_public_function());
</code></pre>
</div>
</div><code class="code-header">pub unconstrained fn <span class="fn">view_public</span>&lt;T, let M: u32&gt;(_self: <a href="../../../../noir_aztec/test/helpers/test_environment/struct.TestEnvironment.html" class="struct">TestEnvironment</a>, call_interface: <a href="../../../../noir_aztec/context/call_interfaces/struct.PublicStaticCallInterface.html" class="struct">PublicStaticCallInterface</a>&lt;M, T&gt;) -> T
where
    T: Deserialize<N = <T as Deserialize>::N>
</code>

<div class="padded-description"><div class="comments">
<p>Variant of <code>call_public</code> for public <code>#[view]</code> functions.</p>
<p>Unlike <code>call_public</code>, no transaction is created and no block is mined (since <code>#[view]</code> functions are only
executable in a static context, and these produce no side effects).</p>
</div>
</div></main>
</body>
</html>
