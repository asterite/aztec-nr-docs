<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct PrivateSet documentation</title>
</head>
<body>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">noir_aztec</a>::<a href="../index.html">state_vars</a>::<a href="index.html">private_set</a></div><h1>Struct <span class="struct">PrivateSet</span></h1><pre><code>pub struct PrivateSet&lt;Note, Context&gt; {
    pub context: Context,
    pub storage_slot: Field,
}
</code></pre>
<div class="comments">
<h2>PrivateSet</h2>
<p>PrivateSet is a private state variable type, which enables you to read, mutate,
and write private state within the #[private] functions of your smart contract.</p>
<p>You can declare a state variable of type PrivateSet within your contract's
#[storage] struct:</p>
<p>E.g.:
<code>your_variable: PrivateSet&lt;YourNote, Context&gt;</code>
or:
<code>your_mapping: Map&lt;Field, PrivateSet&lt;YourNote, Context&gt;&gt;</code></p>
<p>The PrivateSet type operates over notes, by facilitating: the insertion
of new notes, the reading of existing notes, and the nullification of existing
notes.</p>
<p>The methods of PrivateSet are:</p>
<ul>
<li><code>insert</code></li>
<li><code>pop_notes</code></li>
<li><code>get_notes</code></li>
<li><code>remove</code>
(see the methods' own doc comments for more info).</li>
</ul>
<p>The &quot;current value&quot; of a PrivateSet state variable is represented as a
<em>collection</em> (or &quot;Set&quot;) of multiple notes.</p>
<blockquote>
<p>More exactly, the 'current value' is the collection of all
<em>not-yet-nullified</em> notes in the set.</p>
</blockquote>
<h2>Example.</h2>
<p>A user's token balance can be represented as a PrivateSet of multiple notes,
where the note type contains a value.
The &quot;current value&quot; of the user's token balance (the PrivateSet state variable)
can be interpreted as the summation of the values contained within all
not-yet-nullified notes (aka &quot;current notes&quot;) in the PrivateSet.</p>
<p>This is similar to a physical wallet containing five $10 notes: the owner's
wallet balance is the sum of all those $10 notes: $50.
To spend $2, they can get one $10 note, nullify it, and insert one $8 note as
change. Their new wallet balance will then be interpreted as the new summation: $48.</p>
<p>The interpretation doesn't always have to be a &quot;summation of values&quot;. When
<code>get_notes</code> is called, PrivateSet does not attempt to interpret the notes at all;
it's up to the custom code of the smart contract to make an interpretation.</p>
<p>For example: a set of notes could instead represent a moving average; or a modal
value; or some other single statistic. Or the set of notes might not be
collapsible into a single statistic: it could be a disjoint collection of NFTs
which are housed under the same &quot;storage slot&quot;.</p>
<p>It's worth noting that a user can prove existence of <em>at least</em> some subset
of notes in a PrivateSet, but they cannot prove existence of <em>all</em> notes
in a PrivateSet.
The physical wallet is a good example: a user can prove that there are five
$10 notes in their wallet by furnishing those notes. But because we cannot
<em>see</em> the entirety of their wallet, they might have many more notes that
they're choosing to not showing us.</p>
<h2>When to choose PrivateSet vs PrivateMutable:</h2>
<ul>
<li>If you want <em>someone else</em> (other than the owner of the private state) to be
able to make edits (insert notes).</li>
<li>If you don't want to leak the storage_slot being initialized (see the
PrivateMutable file).</li>
<li>If you find yourself needing to re-initialize a PrivateMutable (see that file).</li>
</ul>
<p>The 'current' value of a <em>PrivateMutable</em> state variable is only ever represented
by <em>one</em> note at a time. To mutate the current value of a PrivateMutable, the
current note always gets nullified, and a new, replacement note gets inserted.
So if nullification is always required to mutate a PrivateMutable, that means
only the 'owner' of a given PrivateMutable state variable can ever mutate it.
For some use cases, this can be too limiting: A key feature of some smart contract
functions is that <em>multiple people</em> are able to mutate a particular state
variable.</p>
<p>PrivateSet enables &quot;other people&quot; (other than the owner of the private state) to
mutate the 'current' value, with some limitations:
The 'owner' is still the only person with the ability to <code>remove</code> notes from the
the set.
&quot;Other people&quot; can <code>insert</code> notes into the set.</p>
<p>It's important to notice that the &quot;owner&quot; of a state variable is an abstract
concept which will differ depending on the rules of a smart contract. When we
talk about the &quot;owner&quot; in the context of these aztec-nr files, we tend to mean
&quot;the person who has the ability to nullify the state variable's notes&quot;.
Notice that the state variable abstractions of aztec-nr do not know what an
&quot;owner&quot; is: they delegate responsibility of understanding who the &quot;owner&quot; of a
note is to the note itself, via a <code>compute_nullifier</code> call.</p>
<h2>Privacy</h2>
<p>The methods of a PrivateSet are only executable in a PrivateContext, and are
designed to not leak anything about <em>which</em> state variable was read/modified/
inserted, to the outside world.</p>
<p>The design of the Note does impact the privacy of the state variable: the note
will need to contain a <code>randomness</code> field so that, when hashed, the contents of
the note are private.</p>
<blockquote>
<p>Note: we decided to explicitly require <code>randomness</code> in a note definition,
because we anticipated use cases where notes might also be used to store
certain <em>public</em> state. We might roll-back that decision, so that users don't
need to worry about handling their own randomness when defining custom notes.</p>
</blockquote>
<p>The design of the note's custom <code>compute_nullifier</code> method will also impact the
privacy of the note at the time it is nullified. (Note: all Notes must implement
<code>compute_nullifier</code> to be compatible with PrivateSet). See the docs.</p>
<h2>Struct Fields:</h2>
<ul>
<li>
<p>context - The execution context (PrivateContext or UtilityContext).</p>
</li>
<li>
<p>storage_slot -  All notes that &quot;belong&quot; to a given PrivateSet state variable
are augmented with a common <code>storage_slot</code> field, as a way of
identifying which set they belong to. (Management of <code>storage_slot</code> is handled
within the innards of the PrivateSet impl, so you shouldn't need to think about
this any further).</p>
</li>
</ul>
<h2>Generic Parameters:</h2>
<ul>
<li><code>Note</code> - Many notes of this type will collectively form the PrivateSet at the
given storage_slot.</li>
<li><code>Context</code> - The execution context (PrivateContext or UtilityContext).</li>
</ul>
<p>docs:start:struct</p>
</div>
<h2>Fields</h2><h3><code class="code-header">context: Context</code></h3>
<div class="padded-description"></div><h3><code class="code-header">storage_slot: Field</code></h3>
<div class="padded-description"></div><h2>Implementations</h2><h3><code class="code-header">impl&lt;Note&gt; <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, <a href="../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>&gt;</code></h3>

<code class="code-header">pub unconstrained fn <span class="fn">view_notes</span>(self: <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, <a href="../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>&gt;, options: <a href="../../../noir_aztec/note/note_viewer_options/struct.NoteViewerOptions.html" class="struct">NoteViewerOptions</a>&lt;Note, <Note as Packable>::N&gt;) -> BoundedVec&lt;Note, 10&gt;
where
    Note: Packable<N = <Note as Packable>::N>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Returns a collection of notes which belong to this PrivateSet, according
to the given selection <code>options</code>.</p>
<p>Notice that this function is executable only within a UtilityContext, which
is an unconstrained environment on the user's local device.</p>
<h4>Arguments</h4>
<ul>
<li><code>options</code> - See NoteGetterOptions. Enables the caller to specify the
properties of the notes that must be returned by the oracle
call to the PXE.</li>
</ul>
<p>docs:start:view_notes</p>
</div>
</div><h3><code class="code-header">impl&lt;Note&gt; <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;</code></h3>

<code class="code-header">pub fn <span class="fn">insert</span>(self: <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;, note: Note) -> <a href="../../../noir_aztec/note/note_emission/struct.NoteEmission.html" class="struct">NoteEmission</a>&lt;Note&gt;
where
    Note: Packable<N = <Note as Packable>::N>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Inserts a new <code>note</code> into the PrivateSet.</p>
<h4>Arguments</h4>
<ul>
<li><code>note</code> - A newly-created note that you would like to insert into this
PrivateSet.</li>
</ul>
<h4>Returns</h4>
<ul>
<li>NoteEmission&lt;Note&gt; - A type-safe wrapper which makes it clear to the
smart contract dev that they now have a choice: they
need to decide whether they would like to send the contents of the newly-
created note to someone, or not. If they would like to, they have some
further choices:
<ul>
<li>What kind of log to use? (Private log, or offchain log).</li>
<li>What kind of encryption scheme to use? (Currently only AES128 is supported)</li>
<li>Whether to <em>constrain</em> delivery of the note, or not.
At the moment, aztec-nr provides limited options.
You can call <code>.emit()</code> on the returned type to encrypt and log the note, or
<code>.discard()</code> to skip emission.
See NoteEmission for more details.</li>
</ul>
<blockquote>
<p>Note: We're planning a <em>significant</em> refactor of this syntax, to make the
syntax of how to encrypt and deliver notes much clearer, and to make the
default options much clearer to developers. We will also be enabling
easier ways to customize your own note encryption options.</p>
</blockquote>
</li>
</ul>
<h4>Advanced:</h4>
<p>Ultimately, this function inserts the <code>note</code> into the protocol's Note Hash
Tree.
Behind the scenes, we do the following:</p>
<ul>
<li>Augment the note with the <code>storage_slot</code> of this PrivateSet, to
convey which set it belongs to.</li>
<li>Augment the note with a <code>note_type_id</code>, so that it can be correctly filed-
away when it is eventually discovered, decrypted, and processed by its
intended recipient.
(The note_type_id is usually allocated by the #[note] macro).</li>
<li>Provide the contents of the (augmented) note to the PXE, so that it can
store all notes created by the user executing this function.
<ul>
<li>The note is also kept in the PXE's memory during execution, in case this
newly-created note gets <em>read</em> in some later execution frame of this
transaction. In such a case, we feed hints to the kernel to squash:
the so-called &quot;transient note&quot;, its note log (if applicable), and the
nullifier that gets created by the reading function.</li>
</ul>
</li>
<li>Hash the (augmented) note into a single Field, via the note's own
<code>compute_note_hash</code> method.</li>
<li>Push the <code>note_hash</code> to the PrivateContext. From here, the protocol's
kernel circuits will take over and insert the note_hash into the protocol's
&quot;note hash tree&quot;.
<ul>
<li>Before insertion, the protocol will:
<ul>
<li>&quot;Silo&quot; the <code>note_hash</code> with the <code>contract_address</code> of the calling
function, to yield a <code>siloed_note_hash</code>. This prevents state collisions
between different smart contracts.</li>
<li>Ensure uniqueness of the <code>siloed_note_hash</code>, to prevent Faerie-Gold
attacks, by hashing the <code>siloed_note_hash</code> with a unique value, to
yield a <code>unique_siloed_note_hash</code> (see the protocol spec for more).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>docs:start:insert</p>
</div>
</div><code class="code-header">pub fn <span class="fn">pop_notes</span>&lt;PreprocessorArgs, FilterArgs, let M: u32&gt;(self: <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;, options: <a href="../../../noir_aztec/note/note_getter_options/struct.NoteGetterOptions.html" class="struct">NoteGetterOptions</a>&lt;Note, M, PreprocessorArgs, FilterArgs&gt;) -> BoundedVec&lt;Note, 16&gt;
where
    Note: Packable<N = M>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Pops a collection of &quot;current&quot; notes (i.e. not-yet-nullified notes) which
belong to this PrivateSet.</p>
<p>&quot;Pop&quot; indicates that, conceptually, the returned notes will get <em>permanently
removed</em> (nullified) from the PrivateSet by this method.</p>
<p>The act of nullifying convinces us that the returned notes are indeed
&quot;current&quot; (because if they can be nullified, it means they haven't been
nullified already, because a note can only be nullified once).</p>
<p>This means that -- whilst the returned notes should be considered &quot;current&quot;
within the currently-executing execution frame of the tx -- they will be not
be considered &quot;current&quot; by any <em>later</em> execution frame of this tx (or any
future tx).</p>
<p>Notes will be selected from the PXE's database, via an oracle call, according
to the filtering <code>options</code> provided.</p>
<h4>Arguments</h4>
<ul>
<li><code>options</code> - See NoteGetterOptions. Enables the caller to specify the
properties of the notes that must be returned by the oracle
call to the PXE.
The NoteGetterOptions are designed to contain functions which
<em>constrain</em> that the returned notes do indeed adhere to the
specified options. Those functions are executed <em>within</em> this
<code>pop_notes</code> call.</li>
</ul>
<h4>Returns</h4>
<ul>
<li>BoundedVec&lt;Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL&gt;
<ul>
<li>A vector of &quot;current&quot; notes, that have been constrained to satisfy the
retrieval criteria specified by the given <code>options</code>.</li>
</ul>
</li>
</ul>
<h4>Generic Parameters</h4>
<ul>
<li><code>PreprocessorArgs</code> - See <code>NoteGetterOptions</code>.</li>
<li><code>FilterArgs</code> - See <code>NoteGetterOptions</code>.</li>
<li><code>M</code> - The length of the note (in Fields), when packed by the Packable trait.</li>
</ul>
<h4>Advanced:</h4>
<p>Reads the notes:</p>
<ul>
<li>Gets notes from the PXE, via an oracle call, according to the filtering
<code>options</code> provided.</li>
<li>Constrains that the returned notes do indeed adhere to the <code>options</code>.
(Note: the <code>options</code> contain <em>constrained</em> functions that get invoked
<em>within</em> this function).</li>
<li>Asserts that the notes do indeed belong to this calling function's
<code>contract_address</code>, and to this PrivateSet's <code>storage_slot</code>.</li>
<li>Computes the note_hash for each note, using the <code>storage_slot</code> and
<code>contract_address</code> of this PrivateSet instance.</li>
<li>Asserts that the note_hash does indeed exist:
<ul>
<li>For settled notes: makes a request to the kernel to perform a merkle
membership check against the historical Note Hashes Tree that this tx
is referencing.</li>
<li>For transient notes: makes a request to the kernel to ensure that the
note was indeed emitted by some earlier execution frame of this tx.</li>
</ul>
</li>
</ul>
<p>Nullifies the notes:</p>
<ul>
<li>Computes the nullifier for each note.
<ul>
<li>(The nullifier computation differs depending on whether the note is
settled or transient).</li>
</ul>
</li>
<li>Pushes the nullifiers to the PrivateContext. From here, the protocol's
kernel circuits will take over and insert the nullifiers into the
protocol's &quot;nullifier tree&quot;.
<ul>
<li>Before insertion, the protocol will:
<ul>
<li>&quot;Silo&quot; each <code>nullifier</code> with the <code>contract_address</code> of the calling
function, to yield a <code>siloed_nullifier</code>. This prevents nullifier
collisions between different smart contracts.</li>
<li>Ensure that each <code>siloed_nullifier</code> does not already exist in the
nullifier tree. The nullifier tree is an indexed merkle tree, which
supports efficient non-membership proofs.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div><code class="code-header">pub fn <span class="fn">remove</span>(self: <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;, retrieved_note: <a href="../../../noir_aztec/note/retrieved_note/struct.RetrievedNote.html" class="struct">RetrievedNote</a>&lt;Note&gt;)
where
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Permanently removes (conceptually) the given note from this PrivateSet,
by nullifying it.</p>
<p>Note that if you obtained the note via <code>get_notes</code> it's much better to use
<code>pop_notes</code>, as <code>pop_notes</code> results in significantly fewer constraints,
due to avoiding an extra hash and read request check.</p>
<h4>Arguments</h4>
<ul>
<li><code>retrieved_note</code> - A note which -- earlier in the calling function's
execution -- has been retrieved from the PXE.
The <code>retrieved_note</code> is constrained to have been read
from the i</li>
</ul>
<h4>Returns</h4>
<ul>
<li>NoteEmission&lt;Note&gt; - A type-safe wrapper which makes it clear to the
smart contract dev that they now have a choice: they
need to decide whether they would like to send the contents of the newly-
created note to someone, or not. If they would like to, they have some
further choices:
<ul>
<li>What kind of log to use? (Private log, or offchain log).</li>
<li>What kind of encryption scheme to use? (Currently only AES128 is supported)</li>
<li>Whether to <em>constrain</em> delivery of the note, or not.
At the moment, aztec-nr provides limited options.
See NoteEmission for further details.</li>
</ul>
<blockquote>
<p>Note: We're planning a <em>significant</em> refactor of this syntax, to make the
syntax of how to encrypt and deliver notes much clearer, and to make the
default options much clearer to developers. We will also be enabling
easier ways to customize your own note encryption options.</p>
</blockquote>
</li>
</ul>
</div>
</div><code class="code-header">pub fn <span class="fn">get_notes</span>&lt;PreprocessorArgs, FilterArgs, let M: u32&gt;(self: <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;, options: <a href="../../../noir_aztec/note/note_getter_options/struct.NoteGetterOptions.html" class="struct">NoteGetterOptions</a>&lt;Note, M, PreprocessorArgs, FilterArgs&gt;) -> BoundedVec&lt;<a href="../../../noir_aztec/note/retrieved_note/struct.RetrievedNote.html" class="struct">RetrievedNote</a>&lt;Note&gt;, 16&gt;
where
    Note: Packable<N = M>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: Eq
</code>

<div class="padded-description"><div class="comments">
<p>Returns a collection of which belong to this PrivateSet.</p>
<p>DANGER: the returned notes do not get nullified within this <code>get_notes</code>
function, and so they cannot necessarily be considered &quot;current&quot; notes.
I.e. you might be reading notes that have already been nullified. It is
this which distinguishes <code>get_notes</code> from <code>pop_notes</code>.</p>
<p>Note that if you later on remove the note it's much better to use
<code>pop_notes</code> as <code>pop_notes</code> results in significantly fewer constrains
due to avoiding 1 read request check.
If you need for your app to see the notes before it can decide which to
nullify (which ideally would not be the case, and you'd be able to rely
on the filter and preprocessor to do this), then you have no resort but
to call <code>get_notes</code> and then <code>remove</code>.</p>
<p>Notes will be selected from the PXE's database, via an oracle call, according
to the filtering <code>options</code> provided.</p>
<h4>Arguments</h4>
<ul>
<li><code>options</code> - See NoteGetterOptions. Enables the caller to specify the
properties of the notes that must be returned by the oracle
call to the PXE.
The NoteGetterOptions are designed to contain functions which
<em>constrain</em> that the returned notes do indeed adhere to the
specified options. Those functions are executed <em>within</em> this
<code>pop_notes</code> call.</li>
</ul>
<h4>Returns</h4>
<ul>
<li>BoundedVec&lt;Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL&gt;
<ul>
<li>A vector of &quot;current&quot; notes, that have been constrained to satisfy the
retrieval criteria specified by the given <code>options</code>.</li>
</ul>
</li>
</ul>
<h4>Generic Parameters</h4>
<ul>
<li><code>PreprocessorArgs</code> - See <code>NoteGetterOptions</code>.</li>
<li><code>FilterArgs</code> - See <code>NoteGetterOptions</code>.</li>
<li><code>M</code> - The length of the note (in Fields), when packed by the Packable trait.</li>
</ul>
<h4>Advanced:</h4>
<p>Reads the notes:</p>
<ul>
<li>Gets notes from the PXE, via an oracle call, according to the filtering
<code>options</code> provided.</li>
<li>Constrains that the returned notes do indeed adhere to the <code>options</code>.
(Note: the <code>options</code> contain <em>constrained</em> functions that get invoked
<em>within</em> this function).</li>
<li>Asserts that the notes do indeed belong to this calling function's
<code>contract_address</code>, and to this PrivateSet's <code>storage_slot</code>.</li>
<li>Computes the note_hash for each note, using the <code>storage_slot</code> and
<code>contract_address</code> of this PrivateSet instance.</li>
<li>Asserts that the note_hash does indeed exist:
<ul>
<li>For settled notes: makes a request to the kernel to perform a merkle
membership check against the historical Note Hashes Tree that this tx
is referencing.</li>
<li>For transient notes: makes a request to the kernel to ensure that the
note was indeed emitted by some earlier execution frame of this tx.</li>
</ul>
</li>
</ul>
</div>
</div><h3><code class="code-header">impl&lt;Context, Note&gt; <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, Context&gt;</code></h3>

<code class="code-header">pub fn <span class="fn">new</span>(context: Context, storage_slot: Field) -> <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;Note, Context&gt;</code>

<div class="padded-description"><div class="comments">
<p>Initializes a new PrivateSet state variable.</p>
<p>This function is usually automatically called within the #[storage] macro.
You typically don't need to call this directly when writing smart contracts.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - One of <code>PrivateContext</code>/<code>PublicContext</code>/<code>UtilityContext</code>. The
Context determines which methods of this struct will be made
available to the calling smart contract function.</li>
<li><code>storage_slot</code> - A unique identifier for this state variable within the
contract. All notes that &quot;belong&quot; to a given PrivateSet
state variable are augmented with a common <code>storage_slot</code>
field, as a way of identifying which set they belong to.
Usually, the #[storage] macro will determine an appropriate
storage_slot automatically. A smart contract dev shouldn't
have to worry about this, as it's managed behind the scenes.</li>
</ul>
<p>docs:start:new</p>
</div>
</div><h2>Trait implementations</h2><h3><code class="code-header">impl&lt;Context, T&gt; <a href="../../../noir_aztec/state_vars/storage/trait.HasStorageSlot.html" class="trait">HasStorageSlot</a>&lt;1&gt; for <a href="../../../noir_aztec/state_vars/private_set/struct.PrivateSet.html" class="struct">PrivateSet</a>&lt;T, Context&gt;</code></h3>

</main>
</body>
</html>
