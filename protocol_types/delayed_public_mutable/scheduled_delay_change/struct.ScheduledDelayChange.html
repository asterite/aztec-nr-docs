<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct ScheduledDelayChange documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">aztec-nr</a></h1><div><a href="../../../all.html">All items</a></div>
<h2><a href="#struct">Struct ScheduledDelayChange</a></h2><h3>Methods</h3><ul class="sidebar-list"><li><a href="#get_current">get_current</a></li>
<li><a href="#get_effective_minimum_delay_at">get_effective_minimum_delay_at</a></li>
<li><a href="#get_scheduled">get_scheduled</a></li>
<li><a href="#new">new</a></li>
<li><a href="#schedule_change">schedule_change</a></li>
</ul><h3>Trait implementations</h3><ul class="sidebar-list"><li><a href="#impl-Empty-for-ScheduledDelayChange">Empty</a></li>
<li><a href="#impl-Eq-for-ScheduledDelayChange">Eq</a></li>
</ul><h2>In module scheduled_delay_change</h2><h3>Structs</h3><ul class="item-list"><li><a href="struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a></div></li>
</ul></nav>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">protocol_types</a>::<a href="../index.html">delayed_public_mutable</a>::<a href="index.html">scheduled_delay_change</a></div><h1>Struct <span id="struct" class="struct">ScheduledDelayChange</span></h1><pre><code>pub struct ScheduledDelayChange&lt;let INITIAL_DELAY: u64&gt;
{ <span class="comment">/* private fields */</span> }
</code></pre>
<h2>Implementations</h2><h3><code class="code-header">impl&lt;let INITIAL_DELAY: u64&gt; <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;</code></h3>

<div class="padded-methods"><code id="new" class="code-header">pub fn <span class="fn">new</span>(
    pre: <a href="../../../std/option/struct.Option.html" class="struct">Option</a>&lt;u64&gt;,
    post: <a href="../../../std/option/struct.Option.html" class="struct">Option</a>&lt;u64&gt;,
    timestamp_of_change: u64,
) -> <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;</code>

<code id="get_current" class="code-header">pub fn <span class="fn">get_current</span>(self: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;, current_timestamp: u64) -> u64</code>

<div class="padded-description"><div class="comments">
<p>Returns the current value of the delay stored in the data structure.
This function only returns a meaningful value when called in public with the current timestamp - for
historical private reads use <code>get_effective_minimum_delay_at</code> instead.</p>
</div>
</div><code id="get_scheduled" class="code-header">pub fn <span class="fn">get_scheduled</span>(self: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;) -> (u64, u64)</code>

<div class="padded-description"><div class="comments">
<p>Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current
delay. Note that this timestamp may be in the past if the change has already taken place.
Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.</p>
</div>
</div><code id="schedule_change" class="code-header">pub fn <span class="fn">schedule_change</span>(
    &mut self: &mut <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;,
    new: u64,
    current_timestamp: u64,
)</code>

<div class="padded-description"><div class="comments">
<p>Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful
when called in public with the current timestamp.
The timestamp at which the new delay will become effective is determined automatically:</p>
<ul>
<li>when increasing the delay, the change is effective immediately</li>
<li>when reducing the delay, the change will take effect after a delay equal to the difference between old and
new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2
days.</li>
</ul>
</div>
</div><code id="get_effective_minimum_delay_at" class="code-header">pub fn <span class="fn">get_effective_minimum_delay_at</span>(self: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;, historical_timestamp: u64) -> u64</code>

<div class="padded-description"><div class="comments">
<p>Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some
historical timestamp (timestamp of a historical block). It only returns a meaningful value when called in
private with historical timestamps. This function can be used alongside
<code>ScheduledValueChange.get_time_horizon</code> to properly constrain the <code>include_by_timestamp</code> transaction
property when reading delayed mutable state.
This value typically equals the current delay at the timestamp following the historical one (the earliest one in
which a value change could be scheduled), but it also considers scenarios in which a delay reduction is
scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than
the current one.</p>
</div>
</div></div><h2>Trait implementations</h2><h3 id="impl-Empty-for-ScheduledDelayChange"><code class="code-header">impl&lt;let INITIAL_DELAY: u64&gt; <a href="../../../protocol_types/traits/trait.Empty.html" class="trait">Empty</a> for <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;</code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">empty</span>() -> <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;</code>

<code class="code-header">pub fn <span class="fn">is_empty</span>(self: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;) -> bool</code>

<code class="code-header">pub fn <span class="fn">assert_empty</span>&lt;let S: u32&gt;(self: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;, msg: str&lt;S&gt;)</code>

</div><h3 id="impl-Eq-for-ScheduledDelayChange"><code class="code-header">impl&lt;let INITIAL_DELAY: u64&gt; <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;</code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">eq</span>(self: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;, other: <a href="../../../protocol_types/delayed_public_mutable/scheduled_delay_change/struct.ScheduledDelayChange.html" class="struct">ScheduledDelayChange</a>&lt;INITIAL_DELAY&gt;) -> bool</code>

</div></main>
</body>
</html>
