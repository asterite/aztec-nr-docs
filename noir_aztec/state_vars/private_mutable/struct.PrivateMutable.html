<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct PrivateMutable documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">aztec-nr</a></h1>
<div><a href="../../../all.html">All items</a></div>
<h2><a href="#struct">Struct PrivateMutable</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#compute_initialization_nullifier">compute_initialization_nullifier</a></li>
<li><a href="#get_note">get_note</a></li>
<li><a href="#initialize">initialize</a></li>
<li><a href="#initialize_or_replace">initialize_or_replace</a></li>
<li><a href="#is_initialized">is_initialized</a></li>
<li><a href="#new">new</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#view_note">view_note</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-HasStorageSlot&lt;1&gt;-for-PrivateMutable<T, Context>">HasStorageSlot&lt;1&gt;</a></li>
</ul>
<h2>In module private_mutable</h2>
<h3>Structs</h3><ul class="item-list">
<li><a href="struct.PrivateMutable.html" class="struct">PrivateMutable</a></div></li>
</ul>
</nav>
<main>
<div><a href="../../../index.html">aztec-nr</a> - <a href="../../index.html">noir_aztec</a>::<a href="../index.html">state_vars</a>::<a href="index.html">private_mutable</a></div><h1>Struct <span id="struct" class="struct">PrivateMutable</span></h1>
<pre><code>pub struct PrivateMutable&lt;Note, Context&gt;
{ <span class="comment">/* private fields */</span> }
</code></pre>
<div class="comments">
<h2>PrivateMutable</h2>
<p>PrivateMutable is a private state variable type, which enables you to read, mutate,
and write private state within the #[private] functions of your smart contract.</p>
<p>You can declare a state variable of type PrivateMutable within your contract's
#[storage] struct:</p>
<p>E.g.:
<code>your_variable: PrivateMutable&lt;YourNote, Context&gt;</code>
or:
<code>your_mapping: Map&lt;Field, PrivateMutable&lt;YourNote, Context&gt;&gt;</code></p>
<p>The 'current' value of a PrivateMutable state variable is represented as a
<em>single</em> note at any given time.</p>
<blockquote>
<p>More exactly, the 'current value' is the most recently inserted note that
has not yet been nullified.</p>
</blockquote>
<p>This is conceptually similar to how a regular variable works in Ethereum:
the state variable has exactly one value at any point in time. However, the
underlying implementation differs significantly because of Aztec's private
state model.</p>
<p>The PrivateMutable type operates over notes. A PrivateMutable state variable is
initialized by inserting a very first note. Subsequently, the PrivateMutable
can make changes to the state variable's value by nullifying the current note
and inserting a replacement note.</p>
<p>The methods of PrivateMutable are:</p>
<ul>
<li><code>initialize</code></li>
<li><code>replace</code></li>
<li><code>initialize_or_replace</code></li>
<li><code>get_note</code>
(see the methods' own doc comments for more info).</li>
</ul>
<h2>Example</h2>
<p>A user's account nonce can be represented as a PrivateMutable&lt;NonceNote&gt;.
The &quot;current value&quot; of the user's nonce is the value contained within the
single not-yet-nullified note in this PrivateMutable.</p>
<p>When the nonce needs to be incremented, the current note gets nullified
and a new note with the incremented nonce gets inserted. The new note then
becomes the &quot;current value&quot; of the PrivateMutable state variable.</p>
<p>This is similar to how <code>uint256 nonce</code> would work in Solidity: there's always
exactly one current value, and updating it overwrites the previous value.</p>
<h2>When to choose PrivateMutable vs PrivateSet:</h2>
<ul>
<li>Use PrivateMutable when you want exactly one note to represent the state
variable's current value, similar to regular variables in Ethereum.</li>
<li>Use PrivateMutable when you want only the 'owner' of the private state to
be able to make changes to it.</li>
<li>Use PrivateSet when you want multiple notes to collectively represent the
state variable's current value (like a collection of token balance notes).</li>
<li>Use PrivateSet when you want to allow &quot;other people&quot; (beyond the owner) to
insert notes into the state variable.</li>
</ul>
<p>Only the 'owner' of a PrivateMutable state variable can mutate it, because
every mutation requires nullifying the current note, and only the owner who
knows the note's content can compute its nullifier.</p>
<h2>Privacy</h2>
<p>The methods of a PrivateMutable are only executable in a PrivateContext, and are
designed to not leak anything about <em>which</em> state variable was read/modified/
initialized, to the outside world.</p>
<p>However, there is one important privacy consideration: the <code>initialize</code> method
creates an &quot;initialization nullifier&quot; that can leak information about which
storage slot was initialized. See the <code>initialize</code> method documentation for
more details, and for a concrete example.</p>
<p>The design of the Note impacts the privacy of the state variable: the note
should contain a <code>randomness</code> field so that, when hashed, the contents are
private. The note's <code>compute_nullifier</code> method will also impact privacy when
the note is nullified.</p>
<h2>Generic Parameters:</h2>
<ul>
<li><code>Note</code> - A single note of this type will represent the PrivateMutable's
current value at the given storage_slot.</li>
<li><code>Context</code> - The execution context (PrivateContext or UtilityContext).</li>
</ul>
<p>docs:start:struct</p>
</div>
<h2>Implementations</h2>
<h3><code class="code-header">impl&lt;Note&gt; <a href="../../../noir_aztec/state_vars/private_mutable/struct.PrivateMutable.html" class="struct">PrivateMutable</a>&lt;Note, &mut <a href="../../../noir_aztec/context/private_context/struct.PrivateContext.html" class="struct">PrivateContext</a>&gt;</code></h3>

<div class="padded-methods"><code id="initialize" class="code-header">pub fn <span class="fn">initialize</span>(self, note: Note) -> <a href="../../../noir_aztec/note/note_emission/struct.NoteEmission.html" class="struct">NoteEmission</a>&lt;Note&gt;
<div class="where-clause">where
    Note: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;Note as Packable&gt;::N&gt;,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a></div></code>

<div class="padded-description"><div class="comments">
<p>Initializes a PrivateMutable state variable instance with its first note.</p>
<p>This function creates the very first note for this state variable. It can
only be called once per PrivateMutable. Subsequent calls will fail because
the initialization nullifier will already exist.</p>
<p>This is conceptually similar to setting an initial value for a variable in
Ethereum smart contracts, except that in Aztec the &quot;value&quot; is represented
as a private note.</p>
<h4>IMPORTANT PRIVACY CONSIDERATION</h4>
<p>This computation is leaky and can compromise privacy under certain
circumstances.</p>
<p>When the initialization nullifier is emitted during this call, an observer
could perform a dictionary or rainbow attack to learn the storage slot and
contract address.</p>
<p>For applications where revealing that a particular state variable has been
initialized is unacceptable, developers should consider alternative approaches
or avoid using PrivateMutable.</p>
<p>This is especially dangerous for initial assignments to elements of a
<code>Map&lt;AztecAddress, PrivateMutable&gt;</code>, because the storage slot often identifies
a specific user. For example, <code>my_map.at(msg.sender).initialize(note)</code> will
leak:</p>
<ul>
<li><code>msg.sender</code>;</li>
<li>the fact that this map element was assigned for the first time;</li>
<li>and the contract's address.</li>
</ul>
<p>See https://github.com/AztecProtocol/aztec-packages/issues/15568 for ideas to
improve this privacy footgun in future.</p>
<h4>Arguments</h4>
<ul>
<li><code>note</code> - The initial note to store in this PrivateMutable. This note
becomes the &quot;current value&quot; of the state variable.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>NoteEmission&lt;Note&gt;</code> - A type-safe wrapper that requires you to decide
whether to encrypt and send the note to someone.
You can call <code>.emit()</code> on it to encrypt and log the note, or <code>.discard()</code>
to skip emission. See NoteEmission for more details.</li>
</ul>
<h4>Advanced</h4>
<p>This function performs the following operations:</p>
<ul>
<li>Creates and emits an initialization nullifier to mark this storage slot
as initialized. This prevents double-initialization.</li>
<li>Inserts the provided note into the protocol's Note Hash Tree.</li>
<li>Returns a NoteEmission type that allows the caller to decide how to encrypt
and deliver the note to its intended recipient.</li>
</ul>
<p>The initialization nullifier is deterministically computed from the storage
slot and can leak privacy information (see <code>compute_initialization_nullifier</code>
documentation).</p>
</div>
</div><code id="replace" class="code-header">pub fn <span class="fn">replace</span>(self, new_note: Note) -> <a href="../../../noir_aztec/note/note_emission/struct.NoteEmission.html" class="struct">NoteEmission</a>&lt;Note&gt;
<div class="where-clause">where
    Note: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;Note as Packable&gt;::N&gt;,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a></div></code>

<div class="padded-description"><div class="comments">
<p>Replaces the current note of a PrivateMutable state variable with a new note.</p>
<p>This function implements the typical &quot;nullify-and-create&quot; pattern for updating
private state in Aztec. It first retrieves the current note, nullifies it
(marking it as &quot;spent&quot;), and then inserts a <code>new_note</code> with the updated data.</p>
<p>This is conceptually similar to updating a variable in Ethereum smart contracts,
except that in Aztec we achieve this by consuming the old note and creating a
new one.</p>
<p>This function can only be called after the PrivateMutable has been initialized.
If called on an uninitialized PrivateMutable, it will fail because there is
no current note to replace.</p>
<h4>Arguments</h4>
<ul>
<li><code>new_note</code> - The new note that will replace the current note. This becomes
the new &quot;current value&quot; of the PrivateMutable.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>NoteEmission&lt;Note&gt;</code> - A type-safe wrapper that requires you to decide
whether to encrypt and send the note to someone.
You can call <code>.emit()</code> on it to encrypt and log
the note, or <code>.discard()</code> to skip emission.
See NoteEmission documentation for more details.</li>
</ul>
<h4>Advanced</h4>
<p>This function performs the following operations:</p>
<ul>
<li>Retrieves the current note from the PXE via an oracle call</li>
<li>Validates that the current note exists and belongs to this storage slot</li>
<li>Computes the nullifier for the current note and pushes it to the context</li>
<li>Inserts the provided <code>new_note</code> into the Note Hash Tree</li>
<li>Returns a NoteEmission type for the <code>new_note</code>, that allows the caller to
decide how to encrypt and deliver this note to its intended recipient.</li>
</ul>
<p>The nullification of the previous note ensures that it cannot be used again,
maintaining the invariant that a PrivateMutable has exactly one current note.</p>
</div>
</div><code id="initialize_or_replace" class="code-header">pub fn <span class="fn">initialize_or_replace</span>(self, note: Note) -> <a href="../../../noir_aztec/note/note_emission/struct.NoteEmission.html" class="struct">NoteEmission</a>&lt;Note&gt;
<div class="where-clause">where
    Note: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;Note as Packable&gt;::N&gt;,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a></div></code>

<div class="padded-description"><div class="comments">
<p>Initializes the PrivateMutable if it's uninitialized, or replaces the current
note if it's already initialized.</p>
<p>This is a convenience function that automatically chooses between <code>initialize</code>
and <code>replace</code> based on whether the PrivateMutable has been previously initialized.
This is useful when you don't know the initialization state beforehand, such
as in functions that may be called multiple times.</p>
<h4>Arguments</h4>
<ul>
<li><code>note</code> - The note to store. If initializing, this becomes the first note.
If replacing, this becomes the new current note.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><code>NoteEmission&lt;Note&gt;</code> - A type-safe wrapper that requires you to decide
whether to encrypt and send the note to someone.
You can call <code>.emit()</code> on it to encrypt and log
the note, or <code>.discard()</code> to skip emission.
See NoteEmission documentation for more details.</li>
</ul>
</div>
</div><code id="get_note" class="code-header">pub fn <span class="fn">get_note</span>(self) -> <a href="../../../noir_aztec/note/note_emission/struct.NoteEmission.html" class="struct">NoteEmission</a>&lt;Note&gt;
<div class="where-clause">where
    Note: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;Note as Packable&gt;::N&gt;,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a></div></code>

<div class="padded-description"><div class="comments">
<p>Reads the current note of a PrivateMutable state variable instance.</p>
<p>This function retrieves the current note, but with an important caveat: reading
a &quot;current&quot; note requires nullifying it to ensure that it is indeed current,
and that it and hasn't been nullified by some earlier transaction.
Having nullified the note, we then need to re-insert a new note with equal
value, so that this value remains available for future functions to read it
as &quot;current&quot;.</p>
<p>This is different from reading variables in Ethereum, where reading doesn't
modify the state. In Aztec's private state model, reading a &quot;current&quot; note
&quot;consumes&quot; it and creates a new note of equal value but with fresh
randomness.</p>
<p>The returned note has the same content as the original but is actually the
newly-created note.</p>
<h4>Returns</h4>
<ul>
<li><code>NoteEmission&lt;Note&gt;</code> - A type-safe wrapper containing the newly-created note.
You still need to decide whether to encrypt and send
the note to someone. You can call <code>.emit()</code> on it to
encrypt and log the note, or <code>.discard()</code> to skip
emission. See NoteEmission documentation for more details.</li>
</ul>
<h4>Advanced</h4>
<p>This function performs the &quot;nullify-and-recreate&quot; pattern:</p>
<ul>
<li>Retrieves the current note from the PXE via an oracle call</li>
<li>Validates that the note exists and belongs to this contract address and
storage slot</li>
<li>Nullifies the current note to ensure that it is indeed current</li>
<li>Creates a new note with identical content but with fresh randomness</li>
<li>Returns a NoteEmission for the new note</li>
</ul>
<p>This pattern ensures that:</p>
<ul>
<li>You're always reading the most up-to-date note</li>
<li>Concurrent transactions can't create race conditions</li>
<li>The note remains available for future reads (via the fresh copy)</li>
</ul>
<p>The kernel will inject a unique nonce into the newly-created note, which means
the new note will have a different nullifier, allowing it to be consumed in
the future.</p>
<p>docs:start:get_note</p>
</div>
</div></div><h3><code class="code-header">impl&lt;Context, Note&gt; <a href="../../../noir_aztec/state_vars/private_mutable/struct.PrivateMutable.html" class="struct">PrivateMutable</a>&lt;Note, Context&gt;</code></h3>

<div class="padded-methods"><code id="new" class="code-header">pub fn <span class="fn">new</span>(context: Context, storage_slot: <a href="../../../std/primitive.Field.html" class="primitive">Field</a>) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Initializes a new PrivateMutable state variable.</p>
<p>This function is usually automatically called within the #[storage] macro.
You typically don't need to call this directly when writing smart contracts.</p>
<h4>Arguments</h4>
<ul>
<li><code>context</code> - One of <code>PrivateContext</code>/<code>PublicContext</code>/<code>UtilityContext</code>. The
Context determines which methods of this struct will be made
available to the calling smart contract function.</li>
<li><code>storage_slot</code> - A unique identifier for this state variable within the
contract. Every replacement note for this PrivateMutable
state variable will have the same <code>storage_slot</code>.
Usually, the #[storage] macro will determine an
appropriate storage_slot automatically. A smart contract
dev shouldn't have to worry about this, as it's managed
behind the scenes.</li>
</ul>
<p>docs:start:new</p>
</div>
</div><code id="compute_initialization_nullifier" class="code-header">pub fn <span class="fn">compute_initialization_nullifier</span>(self) -> <a href="../../../std/primitive.Field.html" class="primitive">Field</a></code>

<div class="padded-description"><div class="comments">
<p>Computes the nullifier that will be created when this PrivateMutable is first
initialized.</p>
<p>This function is primarily used internally by the <code>initialize</code> and
<code>initialize_or_replace</code> methods, but may also be useful for contracts that
need to check if a PrivateMutable has been initialized.</p>
<h4>Returns</h4>
<ul>
<li><code>Field</code> - The nullifier that will be emitted when this PrivateMutable is
first initialized.</li>
</ul>
<h4>Advanced</h4>
<p>The computation uses the Poseidon2 hash function with a specific generator
index to hash the storage slot, creating a deterministic nullifier based on
the storage location.</p>
<p>Note: Subsequent nullifications via the <code>replace</code> method will NOT be leaky
if the underlying note's <code>compute_nullifier()</code> method is designed to ensure privacy
(e.g., by incorporating the note owner's nullifier secret key into the nullifier preimage).</p>
</div>
</div></div><h3><code class="code-header">impl&lt;Note&gt; <a href="../../../noir_aztec/state_vars/private_mutable/struct.PrivateMutable.html" class="struct">PrivateMutable</a>&lt;Note, <a href="../../../noir_aztec/context/utility_context/struct.UtilityContext.html" class="struct">UtilityContext</a>&gt;</code></h3>

<div class="padded-methods"><code id="is_initialized" class="code-header">pub unconstrained fn <span class="fn">is_initialized</span>(self) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a>
<div class="where-clause">where
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a></div></code>

<div class="padded-description"><div class="comments">
<p>Checks whether this PrivateMutable has been initialized.</p>
<p>Notice that this function is executable only within a UtilityContext, which
is an unconstrained environment on the user's local device.</p>
<h4>Returns</h4>
<ul>
<li><code>bool</code> - <code>true</code> if the PrivateMutable has been initialized (the initialization
nullifier exists), <code>false</code> otherwise.</li>
</ul>
</div>
</div><code id="view_note" class="code-header">pub unconstrained fn <span class="fn">view_note</span>(self) -> Note
<div class="where-clause">where
    Note: <a href="../../../protocol_types/traits/trait.Packable.html" class="trait">Packable</a>&lt;N = &lt;Note as Packable&gt;::N&gt;,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteType.html" class="trait">NoteType</a>,
    Note: <a href="../../../noir_aztec/note/note_interface/trait.NoteHash.html" class="trait">NoteHash</a>,
    Note: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a></div></code>

<div class="padded-description"><div class="comments">
<p>Returns the current note in this PrivateMutable without consuming it.</p>
<p>This function is only available in a UtilityContext (unconstrained environment)
and is typically used for off-chain queries, view functions, or testing.</p>
<p>Unlike <code>get_note()</code>, this function does NOT nullify and recreate the note.
It simply reads the current note from the PXE's database without modifying
the state. This makes it suitable for read-only operations.</p>
<p>This is conceptually similar to view functions in Ethereum that don't modify
state.</p>
<h4>Returns</h4>
<ul>
<li><code>Note</code> - The current note stored in this PrivateMutable.</li>
</ul>
<p>docs:start:view_note</p>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-HasStorageSlot&lt;1&gt;-for-PrivateMutable<T, Context>"><code class="code-header">impl&lt;Context, T&gt; <a href="../../../noir_aztec/state_vars/storage/trait.HasStorageSlot.html" class="trait">HasStorageSlot</a>&lt;1&gt; for <a href="../../../noir_aztec/state_vars/private_mutable/struct.PrivateMutable.html" class="struct">PrivateMutable</a>&lt;T, Context&gt;</code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">get_storage_slot</span>(self) -> <a href="../../../std/primitive.Field.html" class="primitive">Field</a></code>

</div></main>
</body>
</html>
